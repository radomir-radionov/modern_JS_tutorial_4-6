///  Modern JavaScript tutorial  ///

// 4.1 Объекты

// Объекты используются для хранения коллекций различных значений и более сложных сущностей.
// Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – это пара «ключ: значение»,
// где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.

// let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта" литерал объекта или литеральная нотация.

// Литералы и свойства
// Для удаления свойства мы можем использовать оператор delete:
// delete user.age;

// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:
// let user = {
//     name: "John",
//     age: 30,
//     "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
//   };

//   Объект, объявленный как константа, может быть изменён
//   Дело в том, что объявление const защищает от изменений только саму переменную , а не её содержимое.

//   Квадратные скобки
//   Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
//   Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифры и не
//   содержал специальные символы, кроме $ и _.
//   user["likes birds"] = true;

//   Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.
//   Пример:
//   let fruit = prompt("Какой фрукт купить?", "apple");
//   let bag = {
//     [fruit]: 5, // имя свойства будет взято из переменной fruit
//   };
//   alert( bag.apple ); // 5, если fruit="apple"

//   Проверка существования свойства, оператор «in»
//   let user = { name: "John", age: 30 };
//   alert( "age" in user ); // true, user.age существует

//   Цикл «for…in»
//   for (key in object) {
//     // тело цикла выполняется для каждого свойства объекта
//   }

//   Упорядочение свойств объекта
//   Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию,
//   остальные располагаются в порядке создания.

//   Итого
// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства (пары ключ-значение), где:

// Ключи свойств должны быть строками или символами (обычно строками).
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
// Дополнительные операторы:

// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).
// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.
// У них есть свои особенности, которые мы изучим позже. Иногда люди говорят что-то вроде «тип данных Array»
//  или «тип данных Date», но формально они не являются отдельными типами, а относятся к типу данных Object.
//  Они лишь расширяют его различными способами.

// Объекты в JavaScript очень мощные. Здесь мы только немного углубились в действительно огромную тему.
//  Мы будем плотно работать с объектами и узнаем о них больше в следующих частях учебника.
// 4.2 Копирование объектов и ссылки

// Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
// Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

// Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.
// Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.

// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

// Если мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.

// Например:

// let user = { name: "Иван" };

// let admin = user; // копируется ссылка

// Сравнение по ссылке

// Два объекта равны только в том случае, если это один и тот же объект.
// Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

// Клонирование и объединение объектов, Object.assign

// метод Object.assign.

// et user = {
//   name: "Иван",
//   age: 30
// };

// let clone = {}; // новый пустой объект

// // скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }

// // теперь в переменной clone находится абсолютно независимый клон объекта
// clone.name = "Пётр"; // изменим в нём данные

// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// Синтаксис:

// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть,
// свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
// Возвращает объект dest.
// Например, объединим несколько объектов в один:

// let user = { name: "Иван" };

// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };

// // копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);

// // теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:

// let user = {
//   name: "Иван",
//   age: 30
// };

// let clone = Object.assign({}, user);
// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.

// Вложенное клонирование

// Итого
// Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта»,
//  а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента
//   функции приводит к копированию этой ссылки, а не самого объекта.

// Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.

// Для «простого клонирования» объекта можно использовать Object.assign. Необходимо помнить, что Object.assign не делает глубокое клонирования
// объекта. Если внутри копируемого объекта есть свойство значение, которого не является примитивом, оно будет передано по ссылке.
// Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки _.cloneDeep(obj).

// 4.3 Сборка мусора

// Достижимость
// Основной концепцией управления памятью в JavaScript является принцип достижимости.
// Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

// Существует базовое множество достижимых значений, которые не могут быть удалены.
// Например:
// Локальные переменные и параметры текущей функции.
// Переменные и параметры других функций в текущей цепочке вложенных вызовов.
// Глобальные переменные.
// (некоторые другие внутренние значения)
// Эти значения мы будем называть корнями.
// Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
// Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект,
// то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы. Далее вы познакомитесь с подробными примерами на эту тему.
// В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами
// и удаляет те, которые стали недостижимы.

// Исходящие ссылки не имеют значения. Только входящие ссылки могут сделать объект достижимым.

// Внутренние алгоритмы
// Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).
// Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
// Сборщик мусора «помечает» (запоминает) все корневые объекты.
// Затем он идёт по их ссылкам и помечает все найденные объекты.
// Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются,
// чтобы в будущем не посещать один и тот же объект дважды.
// …И так далее, пока не будут посещены все ссылки (достижимые от корней).
// Все непомеченные объекты удаляются.

// Интерпретаторы JavaScript применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.
// Вот некоторые из оптимизаций:
// Сборка по поколениям (Generational collection
//     Инкрементальная сборка (Incremental collection)
//     Сборка в свободное время (Idle-time collection)

//     Итого
// Главное из того, что мы узнали:
// Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
// Объекты сохраняются в памяти, пока они достижимы.
// Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.
// Современные интерпретаторы реализуют передовые алгоритмы сборки мусора.

// Некоторые из них освещены в книге «The Garbage Collection Handbook: The Art of Automatic Memory Management» (R. Jones и др.).

// 4.8 Преобразование объектов в примитивы

// Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?
// В этом случае объекты сначала автоматически преобразуются в примитивы, а затем выполняется операция.

// Преобразование к примитивам
// Существуют три варианта преобразований («три хинта»), описанные в спецификации:
// "string"    "number"    "default" (3хинта)
// На практике все встроенные объекты, исключая Date (мы познакомимся с ним чуть позже),
// реализуют "default" преобразования тем же способом, что и "number". И нам следует поступать так же.

// В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:
// Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ),
// если такой метод существует, и передаёт ему хинт.
// Иначе, если хинт равен "string"
// пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
// В случае, если хинт равен "number" или "default"
// пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.

// Методы toString/valueOf
// Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:
// toString -> valueOf для хинта со значением «string».
// valueOf -> toString – в ином случае.
// В отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам.

// Возвращаемые типы
// Нет обязательного требования, чтобы toString() возвращал именно строку, или чтобы метод Symbol.toPrimitive
// возвращал именно число для хинта «number».
// Историческая справка
// По историческим причинам, если toString или valueOf вернёт объект, то ошибки не будет, но такое значение
// будет проигнорировано (как если бы метода вообще не существовало).
// Метод Symbol.toPrimitive, напротив, обязан возвращать примитив, иначе будет ошибка.

// Итого
// Преобразование объектов в примитивы вызывается автоматически многими встроенными функциями и операторами,
//  которые ожидают примитив в качестве аргумента.
// Существует всего 3 типа преобразований (хинтов):
// "string" (для alert и других операций, которым нужна строка)
// "number" (для математических операций)
// "default" (для некоторых операций)
// В спецификации явно указано, какой хинт должен использовать каждый оператор. И существует совсем немного
// операторов, которые не знают, что ожидать, и используют хинт со значением "default". Обычно для встроенных
// объектов хинт "default" обрабатывается так же, как "number". Таким образом, последние два очень часто объединяют вместе.
// Алгоритм преобразований к примитивам следующий:
// Сначала вызывается метод obj[Symbol.toPrimitive](hint), если он существует.
// Иначе, если хинт равен "string"
// происходит попытка вызвать obj.toString(), затем obj.valueOf(), смотря что есть.
// Иначе, если хинт равен "number" или "default"
// происходит попытка вызвать obj.valueOf(), затем obj.toString(), смотря что есть.
// На практике довольно часто достаточно реализовать только obj.toString() как «универсальный»
// метод для всех типов преобразований, возвращающий «читаемое» представление объекта, достаточное для логирования или отладки.

// Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования.
// Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции.
// Например, объекты Date (мы рассмотрим их в статье Дата и время) могут вычитаться, и результатом date1 - date2
// будет временной отрезок между двумя датами.
// Что касается строковых преобразований – они обычно происходят, когда мы выводим объект alert(obj), а также в других случаях,
// когда объект используется как строка.

// 5.1 Методы у примитивов

// JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами.
// У них есть и методы. Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

// Примитив

// Это – значение «примитивного» типа.
// Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

// Объект

// Может хранить множество значений как свойства.
// Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов:
// например, функции тоже являются объектами.

// Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.

// Примитив как объект

// Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol.
// Таким образом, они имеют разный набор методов.

// К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

// Вот, как он работает:

// let str = "Привет";

// alert( str.toUpperCase() ); // ПРИВЕТ
// Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

// Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает
// значение строки и имеет такие полезные методы, как toUpperCase().
// Этот метод запускается и возвращает новую строку (показывается в alert).
// Специальный объект удаляется, оставляя только примитив str.
// Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

// Конструкторы String/Number/Boolean предназначены только для внутреннего пользования

// Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при
// помощи такого синтаксиса как new Number(1) или new Boolean(false).

// В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых
// местах последствия могут быть катастрофическими.

// null/undefined не имеют методов
// Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов.
// В некотором смысле, они «самые примитивные».

// Итого
// Все примитивы, кроме null и undefined, предоставляют множество полезных методов. Мы познакомимся с ними поближе в следующих главах.
// Формально эти методы работают с помощью временных объектов, но движки JavaScript внутренне очень хорошо оптимизируют этот процесс,
// так что их вызов не требует много ресурсов.

// 5.2 Числа

// В современном JavaScript существует два типа чисел:

// Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей
// точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем использовать
// чаще всего. Мы поговорим о них в этой главе.
// BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются
// в случаях, когда необходимо работать со значениями более чем 253 или менее чем -253. Так как BigInt числа нужны достаточно
// редко, мы рассмотрим их в отдельной главе BigInt.

// В JavaScript можно использовать букву "e", чтобы укоротить запись числа. Она добавляется к числу и заменяет указанное количество нулей:
// let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
// alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)

// Шестнадцатеричные, двоичные и восьмеричные числа
// alert( 0xff ); // 255

// toString(base)
// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.
// Например:
// let num = 255;
// alert( num.toString(16) );  // ff
// (123456).toString(36).

// Неточные вычисления
// Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в
//  любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl, Ruby.
//  Сравнение Object.is

//  Итого
// Чтобы писать числа с большим количеством нулей:

// Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
// Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).
// Для других систем счисления:

// Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
// parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
// num.toString(base) представляет число в строковом виде в указанной системе счисления base.
// Для преобразования значений типа 12pt и 100px в число:

// Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции по порядку считывают число из строки до тех пор пока не возникнет ошибка.
// Для дробей:

// Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
// Помните, что при работе с дробями происходит потеря точности.
// Ещё больше математических функций:

// Документация по объекту Math. Библиотека маленькая, но содержит всё самое важное.

// 5.3

// Строки
// В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

// Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

// Кавычки
// В JavaScript есть разные типы кавычек.

// Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

// let single = 'single-quoted';
// let double = "double-quoted";

// let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку
//  мы сможем вставлять произвольные выражения, обернув их в ${…}: ${sum(1, 2)}

//  Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

// let guestList = `Guests:
//  * John
//  * Pete
//  * Mary
// `;

// alert(guestList); // список гостей, состоящий из нескольких строк

// Обратные кавычки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой.
// Используемый синтаксис: func`string`. Автоматически вызываемая функция func получает строку и встроенные в неё выражения и может их обработать.

// Спецсимволы

// Символ	Описание
// \n	Перевод строки
// \r	Возврат каретки: самостоятельно не используется. В текстовых файлах Windows для перевода строки используется комбинация символов \r\n.
// \', \"	Кавычки
// \\	Обратный слеш
// \t	Знак табуляции
// \b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.
// \xXX	Символ с шестнадцатеричным юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.
// \uXXXX	Символ в кодировке UTF-16 с шестнадцатеричным кодом XXXX, например, \u00A9 — юникодное представление знака копирайта,
//  ©. Код должен состоять ровно из 4 шестнадцатеричных цифр.

//  Все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».

// Он также используется, если необходимо вставить в строку кавычку.

// К примеру:

// alert( 'I\'m the Walrus!' ); // I'm the Walrus!

// Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — \' — иначе она бы обозначала окончание строки.

// Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка.
// Так что мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки:

// alert( `I'm the Walrus!` ); // I'm the Walrus!

// Длина строки
// Свойство length содержит длину строки:

// alert( `My\n`.length ); // 3
// Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3

// str.length — это числовое свойство, а не функция, добавлять скобки не нужно.

// Доступ к символам
// Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. Также
// можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию:

// let str = `Hello`;

// // получаем первый символ
// alert( str[0] ); // H
// alert( str.charAt(0) ); // H

// // получаем последний символ
// alert( str[str.length - 1] ); // o

// Разница только в том, что если символ с такой позицией отсутствует, тогда [] вернёт undefined, а charAt — пустую строку:

// Также можно перебрать строку посимвольно, используя for..of:

// for (let char of "Hello") {
//   alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
// }

// Строки неизменяемы
// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

// Изменение регистра
// Методы toLowerCase() и toUpperCase() меняют регистр символов:

// alert( 'Interface'.toUpperCase() ); // INTERFACE
// alert( 'Interface'.toLowerCase() ); // interface
// Если мы захотим перевести в нижний регистр какой-то конкретный символ:

// alert( 'Interface'[0].toLowerCase() ); // 'i'

// Поиск подстроки
// Существует несколько способов поиска подстроки.

// str.indexOf
// Первый метод — str.indexOf(substr, pos).

// Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение,
// либо -1 при отсутствии совпадений.

// Например:

// let str = 'Widget with id';

// alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
// alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

// alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with

// При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать:

// let str = "Widget with id";

// if (str.indexOf("Widget")) {
//     alert("Совпадение есть"); // не работает
// }
// Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т. к. str.indexOf("Widget")
// возвращает 0, и if решает, что тест не пройден.

// Поэтому надо делать проверку на -1:

// includes, startsWith, endsWith
// Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

// Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

// alert( "Widget with id".includes("Widget") ); // true

// alert( "Hello".includes("Bye") ); // false
// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

// alert( "Midget".includes("id") ); // true
// alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

// alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
// alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

// Получение подстроки
// В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

// str.slice(start [, end])
// Возвращает часть строки от start до (не включая) end.

// Например:

// let str = "stringify";
// // 'strin', символы от 0 до 5 (не включая 5)
// alert( str.slice(0, 5) );
// // 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
// alert( str.slice(0, 1) );
// Если аргумент end отсутствует, slice возвращает символы до конца строки:

// let str = "stringify";
// alert( str.slice(2) ); // ringify, с позиции 2 и до конца
// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

// let str = "stringify";

// // начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
// alert( str.slice(-4, -1) ); // gif
// str.substring(start [, end])
// Возвращает часть строки между start и end.

// Это — почти то же, что и slice, но можно задавать start больше end.

// Например:

// let str = "stringify";

// // для substring эти два примера — одинаковы
// alert( str.substring(2, 6) ); // "ring"
// alert( str.substring(6, 2) ); // "ring"

// // …но не для slice:
// alert( str.slice(2, 6) ); // "ring" (то же самое)
// alert( str.slice(6, 2) ); // "" (пустая строка)
// Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

// str.substr(start [, length])
// Возвращает часть строки от start длины length.

// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

// let str = "stringify";
// // ring, получаем 4 символа, начиная с позиции 2
// alert( str.substr(2, 4) );
// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

// let str = "stringify";
// // gi, получаем 2 символа, начиная с позиции 4 с конца строки
// alert( str.substr(-4, 2) );
// Давайте подытожим, как работают эти методы, чтобы не запутаться:

// метод	выбирает…	отрицательные значения
// slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
// substring(start, end)	между start и end	отрицательные значения равнозначны 0
// substr(start, length)	length символов, начиная от start	значение start может быть отрицательным

// Какой метод выбрать?
// Все эти методы эффективно выполняют задачу. Формально у метода substr есть небольшой недостаток: он описан не
// в собственно спецификации JavaScript, а в приложении к ней — Annex B. Это приложение описывает возможности языка
// для использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом окружении,
// отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.

// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в
// принципе, можно запомнить только его.

// Сравнение строк
// Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

// Тем не менее, есть некоторые нюансы.

// Строчные буквы больше заглавных:

// alert( 'a' > 'Z' ); // true
// Буквы, имеющие диакритические знаки, идут «не по порядку»:

// alert( 'Österreich' > 'Zealand' ); // true

// Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы,
// позволяющие получить символ по его коду и наоборот.

// str.codePointAt(pos)
// Возвращает код для символа, находящегося на позиции pos:

// // одна и та же буква в нижнем и верхнем регистре
// // будет иметь разные коды
// alert( "z".codePointAt(0) ); // 122

// Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

// Отрицательное число, если str меньше str2.
// Положительное число, если str больше str2.
// 0, если строки равны.
// Например:

// alert( 'Österreich'.localeCompare('Zealand') ); // -1
// У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык
// (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила,
// такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

// Итого
// Есть три типа кавычек. Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения ${…}.
// Строки в JavaScript кодируются в UTF-16.
// Есть специальные символы, такие как \n, и можно добавить символ по его юникодному коду, используя \u….
// Для получения символа используйте [].
// Для получения подстроки используйте slice или substring.
// Для того, чтобы перевести строку в нижний или верхний регистр, используйте toLowerCase/toUpperCase.
// Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение.
// Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
// Строки также имеют ещё кое-какие полезные методы:

// str.trim() — убирает пробелы в начале и конце строки.
// str.repeat(n) — повторяет строку n раз.
// …и другие, которые вы можете найти в справочнике.

// 5.4

// Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

// Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й,
// 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.

// В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов.
// Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.

// Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.

// Объявление
// Существует два варианта синтаксиса для создания пустого массива:

// let arr = new Array();
// let arr = [];

// Элементы массива нумеруются, начиная с нуля.

// Мы можем получить элемент, указав его номер в квадратных скобках:

// let fruits = ["Яблоко", "Апельсин", "Слива"];

// alert( fruits[0] ); // Яблоко
// alert( fruits[1] ); // Апельсин
// alert( fruits[2] ); // Слива

// Мы можем заменить элемент:

// fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
// …Или добавить новый к существующему массиву:

// fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
// Общее число элементов массива содержится в его свойстве length:

// В массиве могут храниться элементы любого типа.

// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

// let fruits = [
//   "Яблоко",
//   "Апельсин",
//   "Слива",
// ];
// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.

// Методы pop/push, shift/unshift
// Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется
//  упорядоченная коллекция элементов, поддерживающая два вида операций:

// push добавляет элемент в конец.
// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

// Существует и другой вариант применения для массивов – структура данных, называемая стек.

// Она поддерживает два вида операций:

// push добавляет элемент в конец.
// pop удаляет последний элемент.
// Таким образом, новые элементы всегда добавляются или удаляются из «конца».

// Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:

// Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.

// В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

// Методы, работающие с концом массива:

// pop
// Удаляет последний элемент из массива и возвращает его:

// let fruits = ["Яблоко", "Апельсин", "Груша"];

// alert( fruits.pop() ); // удаляем "Груша" и выводим его

// alert( fruits ); // Яблоко, Апельсин
// push
// Добавляет элемент в конец массива:

// let fruits = ["Яблоко", "Апельсин"];

// fruits.push("Груша");

// alert( fruits ); // Яблоко, Апельсин, Груша
// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

// Методы, работающие с началом массива:

// shift
// Удаляет из массива первый элемент и возвращает его:

// let fruits = ["Яблоко", "Апельсин", "Груша"];

// alert( fruits.shift() ); // удаляем Яблоко и выводим его

// alert( fruits ); // Апельсин, Груша
// unshift
// Добавляет элемент в начало массива:

// let fruits = ["Апельсин", "Груша"];

// fruits.unshift('Яблоко');

// alert( fruits ); // Яблоко, Апельсин, Груша
// Методы push и unshift могут добавлять сразу несколько элементов:

// let fruits = ["Яблоко"];

// fruits.push("Апельсин", "Груша");
// fruits.unshift("Ананас", "Лимон");

// // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
// alert( fruits );

// Внутреннее устройство массива

// Внутреннее устройство массива
// Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] –
// это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

// Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных,
// а также свойство length. Но в основе всё равно лежит объект.

// Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.

// Варианты неправильного применения массива:

// Добавление нечислового свойства, например: arr.test = 5.
// Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
// Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
// Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют
//  специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными,
//  поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше
//   подойдёт обычный объект {}.

//   Эффективность
//   Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

//   Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.

//   То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо,
//    увеличивая их индексы.

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.

// Действия при операции pop:

// fruits.pop(); // удаляем один элемент с конца

// Метод pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.

// Аналогично работает метод push.

// Перебор элементов
// Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

// let arr = ["Яблоко", "Апельсин", "Груша"];

// for (let i = 0; i < arr.length; i++) {
//   alert( arr[i] );
// }
// Но для массивов возможен и другой вариант цикла, for..of:

// let fruits = ["Яблоко", "Апельсин", "Слива"];

// // проходит по значениям
// for (let fruit of fruits) {
//   alert( fruit );
// }
// Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в
// большинстве случаев этого достаточно. А также это короче.

// Технически, так как массив является объектом, можно использовать и вариант for..in:

// let arr = ["Яблоко", "Апельсин", "Груша"];

// for (let key in arr) {
//   alert( arr[key] ); // Яблоко, Апельсин, Груша
// }
// Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят,
// как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые
// свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам
// приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение
// скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

// В общем, не следует использовать цикл for..in для массивов.

// Немного о «length»
// Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество
// элементов массива, а наибольший цифровой индекс плюс один.

// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

// самый простой способ очистить массив – это arr.length = 0;.

// new Array()
// Существует ещё один вариант синтаксиса для создания массива:

// let arr = new Array("Яблоко", "Груша", "и тд");
// Он редко применяется, так как квадратные скобки [] короче. Кроме того, у него есть хитрая особенность.

// Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.

// Итого
// Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

// Объявление:

// // квадратные скобки (обычно)
// let arr = [item1, item2...];

// // new Array (очень редко)
// let arr = new Array(item1, item2...);
// Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

// Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется
// автоматически методами массива.

// Если мы уменьшаем length вручную, массив укорачивается.

// Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

// push(...items)добавляет items в конец массива.
// pop() удаляет элемент в конце массива и возвращает его.
// shift() удаляет элемент в начале массива и возвращает его.
// unshift(...items) добавляет items в начало массива.
// Чтобы пройтись по элементам массива:

// for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
// for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
// for (let i in arr) – никогда не используйте для массивов!

// 5.5 Методы массивов

// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items.
// Если какой-то из items является массивом, тогда берутся его элементы.
// Для поиска среди элементов:

// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
// Для перебора элементов:

// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:

// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и
// передавая промежуточный результат между вызовами.
// Дополнительно:

// Array.isArray(arr) проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// arr.some(fn)/arr.every(fn) проверяет массив.

// Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true,
//  то метод возвращает true, иначе false.
// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.
// arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target
// (перезаписывает существующие).
// Полный список есть в справочнике MDN.
// На первый взгляд может показаться, что существует очень много разных методов, которые довольно сложно запомнить.
//  Но это гораздо проще, чем кажется.
// Внимательно изучите шпаргалку, представленную выше, а затем, чтобы попрактиковаться, решите задачи, предложенные в данной главе.
//  Так вы получите необходимый опыт в правильном использовании методов массива.
// Всякий раз, когда вам будет необходимо что-то сделать с массивом, а вы не знаете, как это сделать – приходите сюда,
// смотрите на таблицу и ищите правильный метод. Примеры помогут вам всё сделать правильно, и вскоре вы быстро запомните методы
// без особых усилий.

// Задача 1,2,4,5, ,10,11,12

// function sortByAge(arr) {
//   arr.sort((a, b) => (a.age < b.age ? 1 : -1));
// }

// let vasya = { name: "Вася", age: 25 };
// let petya = { name: "Петя", age: 30 };
// let masha = { name: "Маша", age: 28 };

// let arr = [vasya, petya, masha];

// sortByAge(arr);

// // теперь отсортировано: [vasya, masha, petya]
// alert(arr[0].name); // Вася
// alert(arr[1].name); // Маша
// alert(arr[2].name); // Петя

// 5.9 Object.keys, values, entries

// Методы поддерживаются для структур:

// Map
// Set
// Array
// Простые объекты также можно перебирать похожими методами, но синтаксис немного отличается.

// Object.keys, values, entries
// Для простых объектов доступны следующие методы:

// Object.keys(obj) – возвращает массив ключей.
// Object.values(obj) – возвращает массив значений.
// Object.entries(obj) – возвращает массив пар [ключ, значение].
// Обратите внимание на различия (по сравнению с map, например):

// Map	Object
// Синтаксис вызова	map.keys()	Object.keys(obj), не obj.keys()
// Возвращает	перебираемый объект	«реальный» массив

// Первое отличие в том, что мы должны вызвать Object.keys(obj), а не obj.keys().

// Почему так? Основная причина – гибкость. Помните, что объекты являются основой всех сложных структур в JavaScript.
// У нас может быть объект data, который реализует свой собственный метод data.values(). И мы всё ещё можем применять
// к нему стандартный метод Object.values(data).

// Второе отличие в том, что методы вида Object.* возвращают «реальные» массивы, а не просто итерируемые объекты. Это в
//  основном по историческим причинам.

// Object.keys/values/entries игнорируют символьные свойства
// Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.

// Обычно это удобно. Но если требуется учитывать и символьные ключи, то для этого существует отдельный метод
// Object.getOwnPropertySymbols, возвращающий массив только символьных ключей. Также, существует метод Reflect.ownKeys(obj),
// который возвращает все ключи.

// Трансформации объекта
// У объектов нет множества методов, которые есть в массивах, например map, filter и других.

// Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

// Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

// let prices = {
//   banana: 1,
//   orange: 2,
//   meat: 4,
// };

// let doublePrices = Object.fromEntries(
//   // преобразовать в массив, затем map, затем fromEntries обратно объект
//   Object.entries(prices).map(([key, value]) => [key, value * 2])
// );

// alert(doublePrices.meat); // 8
// Это может выглядеть сложным на первый взгляд, но становится лёгким для понимания после нескольких раз использования.

// Можно делать и более сложные «однострочные» преобразования таким путём. Важно только сохранять баланс,
// чтобы код при этом был достаточно простым для понимания.

// function sumSalaries(salaries) {

//   let sum = 0;
//   for (let salary of Object.values(salaries)) {
//     sum += salary;
//   }

//   return sum; // 650
// }

// let salaries = {
//   "John": 100,
//   "Pete": 300,
//   "Mary": 250
// };

// alert( sumSalaries(salaries) ); // 650

// Деструктурирующее присваивание
// В JavaScript есть две чаще всего используемые структуры данных – это Object и Array.

// Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам,
//  а массивы – хранить упорядоченные коллекции данных.

// Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности.

// Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных,
// так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями,
// которые имеют много параметров, значений по умолчанию и так далее.

// Деструктуризация массива
// Пример деструктуризации массива:

// // у нас есть массив с именем и фамилией
// let arr = ["Ilya", "Kantor"]

// // деструктурирующее присваивание
// // записывает firstName=arr[0], surname=arr[1]
// let [firstName, surname] = arr;

// alert(firstName); // Ilya
// alert(surname);  // Kantor
// Теперь мы можем использовать переменные вместо элементов массива.

// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

// let [firstName, surname] = "Ilya Kantor".split(' ');
// «Деструктуризация» не означает «разрушение».
// «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания,
// его задача – только скопировать нужные значения в переменные.

// Это просто короткий вариант записи:

// // let [firstName, surname] = arr;
// let firstName = arr[0];
// let surname = arr[1];
// Пропускайте элементы, используя запятые
// Ненужные элементы массива также могут быть отброшены через запятую:

// // второй элемент не нужен
// let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert( title ); // Consul
// В примере выше второй элемент массива пропускается, а третий присваивается переменной title, оставшиеся элементы
// массива также пропускаются (так как для них нет переменных).

// Работает с любым перебираемым объектом с правой стороны
// …На самом деле мы можем использовать любой перебираемый объект, не только массивы:

// let [a, b, c] = "abc";
// let [one, two, three] = new Set([1, 2, 3]);
// Присваивайте чему угодно с левой стороны
// Мы можем использовать что угодно «присваивающее» с левой стороны.

// Например, можно присвоить свойству объекта:

// let user = {};
// [user.name, user.surname] = "Ilya Kantor".split(' ');
// alert(user.name); // Ilya

// икл с .entries()
// В предыдущей главе мы видели метод Object.entries(obj).

// Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

// let user = {
//   name: "John",
//   age: 30
// };

// // цикл по ключам и значениям
// for (let [key, value] of Object.entries(user)) {
//   alert(`${key}:${value}`); // name:John, затем age:30
// }
// …то же самое для map:

// let user = new Map();
// user.set("name", "John");
// user.set("age", "30");

// for (let [key, value] of user) {
//   alert(`${key}:${value}`); // name:John, затем age:30
// }
// Остаточные параметры «…»
// Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем
//  добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert(name1); // Julius
// alert(name2); // Caesar

// // Обратите внимание, что `rest` является массивом.
// alert(rest[0]); // Consul
// alert(rest[1]); // of the Roman Republic
// alert(rest.length); // 2
// Переменная rest является массивом из оставшихся элементов. Вместо rest можно использовать любое
//  другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на
//   последнем месте в деструктурирующем присваивании.

// Значения по умолчанию
// Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

// let [firstName, surname] = [];

// alert(firstName); // undefined
// alert(surname); // undefined
// Если нам необходимо указать значения по умолчанию, то мы можем использовать =:

// // значения по умолчанию
// let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// alert(name);    // Julius (из массива)
// alert(surname); // Anonymous (значение по умолчанию)
// Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

// Например, здесь мы используем функцию prompt для указания двух значений по умолчанию.
//  Но она будет запущена только для отсутствующего значения:

// // prompt запустится только для surname
// let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

// alert(name);    // Julius (из массива)
// alert(surname); // результат prompt

// Деструктуризация объекта
// Деструктурирующее присваивание также работает с объектами.

// Синтаксис:

// let {var1, var2} = {var1:…, var2:…}
// У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон»
// для соответствующих свойств. В простом случае это список названий переменных в {...}.

// Например:

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// let {title, width, height} = options;

// alert(title);  // Menu
// alert(width);  // 100
// alert(height); // 200
// Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения.
// Вот так – тоже работает:

// // изменён порядок в let {...}
// let {height, width, title} = { title: "Menu", height: 200, width: 100 }\

// Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w,
// то мы можем использовать двоеточие:

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// // { sourceProperty: targetVariable }
// let {width: w, height: h, title} = options;

// // width -> w
// // height -> h
// // title -> title

// alert(title);  // Menu
// alert(w);      // 100
// alert(h);      // 200

// Остаток объекта «…»

// Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
// Можно использовать троеточие, как и для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.
// Выглядит так:

// let options = {
//   title: "Menu",
//   height: 200,
//   width: 100
// };

// // title = свойство с именем title
// // rest = объект с остальными свойствами
// let {title, ...rest} = options;

// // сейчас title="Menu", rest={height: 200, width: 100}
// alert(rest.height);  // 200
// alert(rest.width);   // 100

// Итого
// Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

// Полный синтаксис для объекта:

// let {prop : varName = default, ...rest} = object
// Свойства, которые не были упомянуты, копируются в объект rest.

// Полный синтаксис для массива:

// let [item1 = default, item2, ...rest] = array
// Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.

// 5.11 Дата и время

// объект: Date. Он содержит дату и время, а также предоставляет методы управления ими.
// его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

// let now = new Date();
// alert( now ); // показывает текущие дату и время

// new Date(year, month, date, hours, minutes, seconds, ms)
// year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
// month начинается с 0 (январь) по 11 (декабрь).
// Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
// Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.

// Получение компонентов даты
// Существуют методы получения года, месяца и т.д. из объекта Date:

// getFullYear()
// Получить год (4 цифры)
// getMonth()
// Получить месяц, от 0 до 11.
// getDate()
// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getDay()
// Вернуть день недели от 0 (воскресенье) до 6 (суббота).
// getTime()
// Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
// getTimezoneOffset()
// Возвращает разницу в минутах между местным часовым поясом и UTC:

// Никакого getYear(). Только getFullYear()

// Установка компонентов даты
// Следующие методы позволяют установить компоненты даты и времени:

// setFullYear(year, [month], [date])
// setMonth(month, [date])
// setDate(date)
// setHours(hour, [min], [sec], [ms])
// setMinutes(min, [sec], [ms])
// setSeconds(sec, [ms])
// setMilliseconds(ms)
// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

// Автоисправление даты
// Автоисправление – это очень полезная особенность объектов Date.

// Date.now() ( текущая метка времени)
// Если нужно просто измерить время, объект Date нам не нужен.

// Бенчмаркинг
// вычисления, замеряющие производительность, также называют «бенчмарками» (benchmark).

// Метод Date.parse(str) считывает дату из строки.

// Итого
// Дата и время в JavaScript представлены объектом Date. Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то,
//  и другое.
// Счёт месяцев начинается с нуля (да, январь – это нулевой месяц).
// Дни недели в getDay() также отсчитываются с нуля, что соответствует воскресенью.
// Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых. Это полезно для сложения/вычитания
// дней/месяцев/недель.
// Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект
// Date становится таймстампом.
// Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.

// EX 1
// let date = new Date(2012, 1, 20, 3, 12);
// alert(date);

// EX 2
// let date = new Date(2012, 0, 3); // 3 января 2012 года
// alert(getLocalDay(date)); // вторник, нужно показать 2
// function getLocalDay(date) {
//   let day = date.getDay();

//   if (day == 0) {
//     // день недели 0 (воскресенье) в европейской нумерации будет 7
//     day = 7;
//   }

//   return day;
// }

// EX 3 Какой день месяца был много дней назад?
// function getDateAgo(date, days) {
//   let dateCopy = new Date(date);

//   dateCopy.setDate(date.getDate() - days);
//   return dateCopy.getDate();
// }

// let date = new Date(2015, 0, 2);

// alert(getDateAgo(date, 1)); // 1, (1 Jan 2015)
// alert(getDateAgo(date, 2)); // 31, (31 Dec 2014)

// EX 4 Последнее число месяца?
// function getLastDayOfMonth(year, month) {
//   let date = new Date(year, month + 1, 0);
//   return date.getDate();
// }

// alert(getLastDayOfMonth(2021, 1)); // 31

// 6.1 Рекурсия и стек

// стек контекстов выполнения, вложенный вызов, контекст, базовый случай и рекурсивный случай

// Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена
// на несколько аналогичных, но более простых задач.

// В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач.
// рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее,
// пока значение не станет очевидно.Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.

// function pow(x, n) {
//     if (n == 1) {
//       return x;
//     } else {
//       return x * pow(x, n - 1);
//     }
//   }

//   alert( pow(2, 3) ); // 8

// Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии.В нашем случае она будет равна ровно n.
// рекурсивный способ решения даёт более простой код, который легче поддерживать.

// Контекст выполнения, стек

// Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).
// Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции.
//  Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции,
//  значение this (мы не используем его в данном примере) и прочую служебную информацию.
// Один вызов функции имеет ровно один контекст выполнения, связанный с ним.
// Когда функция производит вложенный вызов, происходит следующее:
// Выполнение текущей функции приостанавливается.
// Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
// Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
// После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

// Текущий контекст «запоминается» на вершине стека.
// Создаётся новый контекст для вложенного вызова.
// Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается,
// и выполнение соответствующей функции продолжается.

// глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.

// Рекурсивные обходы

// Рекурсивные структуры

// Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях.

// Отдел компании – это:

// Либо массив людей.
// Либо объект с отделами.

// Элемент связанного списка определяется рекурсивно как объект с:

// value,
// next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.
// Пример:

// let list = {
//   value: 1,
//   next: {
//     value: 2,
//     next: {
//       value: 3,
//       next: {
//         value: 4,
//         next: null
//       }
//     }
//   }
// };

// Итого
// Термины:

// Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для
// элегантного решения определённых задач.

// Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу
//  настолько простой, что решение не требует дальнейших вложенных вызовов.

// Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя.

// Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).

// list = { value, next -> list }
// Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: они разветвляются, и
// каждая ветвь может содержать другие ветви.

// Как мы видели в примере sumSalary, рекурсивные функции могут быть использованы для прохода по ним.

// Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих
// задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.

// 6.2 Остаточные параметры и оператор расширения

// Остаточные параметры (...)
// Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся параметры и положи их в массив».

// Переменная "arguments"
// Раньше в языке не было остаточных параметров, и получить все аргументы функции можно было только с помощью arguments.
// . Он не поддерживает методы массивов, поэтому мы не можем, например, вызвать arguments.map(...).
// К тому же, arguments всегда содержит все аргументы функции — мы не можем получить их часть. А остаточные параметры позволяют это сделать.
// Стрелочные функции не имеют "arguments"

// Оператор расширения
// Пример;
// let arr = [3, 5, 1];
// alert( Math.max(...arr) ); // 5 (оператор "раскрывает" массив в список аргументов)

// Мы даже можем комбинировать оператор расширения с обычными значениями
// let arr1 = [1, -2, 3, 4];
// let arr2 = [8, 3, -8, 1];
// alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25

// Оператор расширения можно использовать и для слияния массивов:
// let arr = [3, 5, 1];
// let arr2 = [8, 9, 15];
// let merged = [0, ...arr, 2, ...arr2];
// alert(merged); // 0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

// оператор расширения подойдёт для того, чтобы превратить строку в массив символов:
// let str = "Привет";
// alert( [...str] ); // П,р,и,в,е,т
// let str = "Привет";
// // Array.from преобразует перебираемый объект в массив
// alert( Array.from(str) ); // П,р,и,в,е,т

// Результат аналогичен [...str].
// Но между Array.from(obj) и [...obj] есть разница:
// Array.from работает как с псевдомассивами, так и с итерируемыми объектами
// Оператор расширения работает только с итерируемыми объектами
// Выходит, что если нужно сделать из чего угодно массив, то Array.from — более универсальный метод.

// Итого
// Когда мы видим "..." в коде, это могут быть как остаточные параметры, так и оператор расширения.
// Как отличить их друг от друга:
// Если ... располагается в конце списка аргументов функции, то это «остаточные параметры». Он собирает
// остальные неуказанные аргументы и делает из них массив.
// Если ... встретился в вызове функции или где-либо ещё, то это «оператор расширения». Он извлекает элементы из массива.
// Полезно запомнить:
// Остаточные параметры используются, чтобы создавать новые функции с неопределённым числом аргументов.
// С помощью оператора расширения можно вставить массив в функцию, которая по умолчанию работает с
// обычным списком аргументов.
// Вместе эти конструкции помогают легко преобразовывать наборы значений в массивы и обратно.
// К аргументам функции можно обращаться и по-старому — через псевдомассив arguments.

// 6.3 Замыкание

// Лексическое Окружение
// В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект,
// называемый лексическим окружением LexicalEnvironment.
// Объект лексического окружения состоит из двух частей:
// Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация,
// такая как значение this).
// Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

// "Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную»,
// означает, «получить или изменить свойство этого объекта»

// Итого:
// Переменная – это свойство специального внутреннего объекта, связанного с текущим выполняющимся блоком/функцией/скриптом.
// Работа с переменными – это на самом деле работа со свойствами этого объекта.

// Function Declaration
// В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, когда выполнение д
// оходит до них, а раньше, когда создаётся лексическое окружение.
// Для верхнеуровневых функций это означает момент, когда скрипт начинает выполнение.
// Вот почему мы можем вызвать функцию, объявленную через Function Declaration, до того, как она определена.

// Внутреннее и внешнее лексическое окружение
// в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):
// Внутреннее лексическое окружение соответствует текущему выполнению say.
// В нём находится одна переменная name, аргумент функции. Мы вызываем say("John"), так что значение переменной name равно "John".
// Внешнее лексическое окружение – это глобальное лексическое окружение.
// В нём находятся переменная phrase и сама функция.
// У внутреннего лексического окружения есть ссылка outer на внешнее.
// Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем,
// затем в следующем и так далее, до глобального.
// Функция получает текущее значение внешних переменных, то есть, их последнее значение
// Старые значения переменных нигде не сохраняются.
// Один вызов – одно лексическое окружение
// Лексическое окружение – это специальный внутренний объект

// Вложенные функции
// вложенная функция может быть возвращена: либо в качестве свойства нового объекта (если внешняя функция создаёт объект с методами),
// либо сама по себе. И затем может быть использована в любом месте. Не важно где, она всё так же будет иметь доступ к тем же внешним
// переменным.

// 6.4 Устаревшее ключевое слово "var"

// Итого
// Существует 2 основных отличия var от let/const:

// Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
// Объявления (инициализация) переменных varпроизводится в начале исполнения функции (или скрипта для глобальных переменных).

// if (true) {
//     var test = true; // используем var вместо let
//   }

//   alert(test); // true, переменная существует вне блока if
//   Так как var игнорирует блоки, мы получили глобальную переменную test.

// 6.5 Глобальный объект

// Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.
//  По умолчанию это те, что встроены в язык или среду исполнения.

//  Итого
// Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

// Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight
// – высота окна браузера.

// Глобальный объект имеет универсальное имя – globalThis.
// …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js).
// Так как globalThis появился недавно, он не поддерживается в IE и Edge (не-Chromium версия), но можно использовать полифил.
// Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их
// количество к минимуму.
// В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами
// глобального объекта.
// Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую,
//  как window.x.

// 6.6 Объект функции, NFE

// В JavaScript функция – это значение. В JavaScript функции – это объекты.
// Функции можно не только вызывать, но и использовать их как обычные объекты: добавлять/удалять свойства, передавать их по ссылке и т.д.

// Свойство «name»

// function sayHi() {
//     alert("Hi");
//   }

//   alert(sayHi.name); // sayHi

// Что довольно забавно, логика назначения name весьма умная. Она присваивает корректное имя даже в случае,
// когда функция создаётся без имени и тут же присваивается
// В спецификации это называется «контекстное имя»: если функция не имеет name, то JavaScript пытается определить его из контекста.

// Свойство «length»

// function f1(a) {}
// function f2(a, b) {}
// function many(a, b, ...more) {}

// alert(f1.length); // 1
// alert(f2.length); // 2
// alert(many.length); // 2

// Пользовательские свойства

// Свойство не есть переменная
// Свойство функции, назначенное как sayHi.counter = 0, не объявляет локальную переменную counter внутри неё. Другими словами,
//  свойство counter и переменная let counter – это две независимые вещи.
// Мы можем использовать функцию как объект, хранить в ней свойства, но они никак не влияют на её выполнение. Переменные –
// это не свойства функции и наоборот. Это два параллельных мира.

// Named Function Expression

// Named Function Expression или NFE – это термин для Function Expression, у которого есть имя.

// Например, давайте объявим Function Expression:

// let sayHi = function(who) {
//   alert(`Hello, ${who}`);
// };
// И присвоим ему имя:

// let sayHi = function func(who) {
//   alert(`Hello, ${who}`);
// };

// Есть две важные особенности имени func, ради которого оно даётся:

// Оно позволяет функции ссылаться на себя же.
// Оно не доступно за пределами функции.

// Это не работает с Function Declaration
// Трюк с «внутренним» именем, описанный выше, работает только для Function Expression и не работает для Function Declaration.
// Для Function Declaration синтаксис не предусматривает возможность объявить дополнительное «внутреннее» имя.
// Зачастую, когда нам нужно надёжное «внутреннее» имя, стоит переписать Function Declaration на Named Function Expression.

// Итого
// Функции – это объекты.

// Их свойства:

// name – имя функции. Обычно берётся из объявления функции, но если там нет – JavaScript пытается понять его из контекста.
// length – количество аргументов в объявлении функции. Троеточие («остаточные параметры») не считается.
// Если функция объявлена как Function Expression (вне основного потока кода) и имеет имя, тогда это
//  называется Named Function Expression (Именованным Функциональным Выражением). Это имя может быть использовано для ссылки на себя же,
//   для рекурсивных вызовов и т.п.
// Также функции могут содержать дополнительные свойства. Многие известные JavaScript-библиотеки искусно используют эту возможность.
// Они создают «основную» функцию и добавляют множество «вспомогательных» функций внутрь первой. Например, библиотека jQuery создаёт функцию
// с именем $. Библиотека lodash создаёт функцию _, а потом добавляет в неё _.clone, _.keyBy и другие свойства (чтобы узнать о ней побольше
//     см. документацию). Они делают это, чтобы уменьшить засорение глобального пространства имён посредством того, что одна библиотека
//     предоставляет только одну глобальную переменную, уменьшая вероятность конфликта имён.
// Таким образом, функция может не только делать что-то сама по себе, но также и предоставлять полезную функциональность через свои свойства.

// 6.7 Синтаксис "new Function"

// Синтаксис для объявления функции:
// let func = new Function([arg1, arg2, ...argN], functionBody);

// let sum = new Function('a', 'b', 'return a + b');
// alert( sum(1, 2) ); // 3

// А вот функция без аргументов, в этом случае достаточно указать только тело:
// let sayHi = new Function('alert("Hello")');
// sayHi(); // Hello

// Замыкание

// Итого
// Синтаксис:

// let func = new Function ([arg1, arg2, ...argN], functionBody);
// По историческим причинам аргументы также могут быть объявлены через запятую в одной строке.

// Эти 3 объявления ниже эквивалентны:

// new Function('a', 'b', 'return a + b'); // стандартный синтаксис
// new Function('a,b', 'return a + b'); // через запятую в одной строке
// new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке
// Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое окружение, а не на родительское.
// Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что страхует нас от ошибок.
// Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.

// 6.8 Планирование: setTimeout и setInterval

// Для этого существуют два метода:

// setTimeout позволяет вызвать функцию один раз через определённый интервал времени.
// setInterval позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
// setTimeout
// Синтаксис:
// let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
// Параметры:
// func|code
// Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.
// delay
// Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.
// arg1, arg2…
// Аргументы, передаваемые в функцию (не поддерживается в IE9-)
// Например, данный код вызывает sayHi() спустя одну секунду:

// function sayHi() {
//   alert('Привет');
// }

// setTimeout(sayHi, 1000);
// С аргументами:

// function sayHi(phrase, who) {
//   alert( phrase + ', ' + who );
// }

// setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон

// Отмена через clearTimeout

// let timerId = setTimeout(...);
// clearTimeout(timerId);

// setInterval
// Метод setInterval имеет такой же синтаксис как setTimeout:
// let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)

// Рекурсивный setTimeout

// Рекурсивный setTimeout позволяет задать задержку между выполнениями более точно, чем setInterval.
// РекурсивныйsetTimeout гарантирует фиксированную задержку (здесь 100 мс).
// Сборка мусора и колбэк setTimeout/setInterval

// setTimeout с нулевой задержкой

// Итого
// Методы setInterval(func, delay, ...args) и setTimeout(func, delay, ...args) позволяют выполнять
// func регулярно или только один раз после задержки delay, заданной в мс.
// Для отмены выполнения необходимо вызвать clearInterval/clearTimeout со значением, которое возвращают методы setInterval/setTimeout.
// Вложенный вызов setTimeout является более гибкой альтернативой setInterval.
//  Также он позволяет более точно задать интервал между выполнениями.
// Планирование с нулевой задержкой setTimeout(func,0) или, что то же самое, setTimeout(func)
// используется для вызовов, которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
// Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами setTimeout,
// а также для setInterval, начиная с 5-го вызова.
// Обратим внимание, что все методы планирования не гарантируют точную задержку.

// Например, таймер в браузере может замедляться по многим причинам:

// Перегружен процессор.
// Вкладка браузера в фоновом режиме.
// Работа ноутбука от аккумулятора.
// Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 300 или
// даже 1000 мс в зависимости от браузера и настроек производительности ОС.
