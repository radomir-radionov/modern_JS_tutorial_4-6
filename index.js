///  Modern JavaScript tutorial  ///

// 4.1 Объекты

// Объекты используются для хранения коллекций различных значений и более сложных сущностей.

// Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств.
// Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.

// Мы можем представить объект в виде ящика с подписанными папками. Каждый элемент данных хранится в своей папке, на которой написан ключ.
//  По ключу папку легко найти, удалить или добавить в неё что-либо.

//  let user = new Object(); // синтаксис "конструктор объекта"
// let user = {};  // синтаксис "литерал объекта"

// Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией.

// Литералы и свойства
// При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»:

// let user = {     // объект
//   name: "John",  // под ключом "name" хранится значение "John"
//   age: 30        // под ключом "age" хранится значение 30
// };
// У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую.

// В объекте user сейчас находятся два свойства:

// Первое свойство с именем "name" и значением "John".
// Второе свойство с именем "age" и значением 30.

// Для обращения к свойствам используется запись «через точку»:

// // получаем свойства объекта:
// alert( user.name ); // John
// alert( user.age ); // 30

// Значение может быть любого типа. Давайте добавим свойство с логическим значением:

// user.isAdmin = true;

// Для удаления свойства мы можем использовать оператор delete:

// delete user.age;

// Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки:

// let user = {
//   name: "John",
//   age: 30,
//   "likes birds": true  // имя свойства из нескольких слов должно быть в кавычках
// };

// Последнее свойство объекта может заканчиваться запятой:

// let user = {
//   name: "John",
//   age: 30,
// }
// Это называется «висячая запятая». Такой подход упрощает добавление, удаление и перемещение свойств,
//  так как все строки объекта становятся одинаковыми.

//  Объект, объявленный как константа, может быть изменён
// Объект, объявленный через const, может быть изменён.

// Например:

// const user = {
//   name: "John"
// };

// user.name = "Pete"; // (*)

// alert(user.name); // Pete
// Может показаться, что строка (*) должна вызвать ошибку, но нет, здесь всё в порядке. Дело в том,
//  что объявление const защищает от изменений только саму переменную user, а не её содержимое.

// Определение const выдаст ошибку только если мы присвоим переменной другое значение: user=....

// Квадратные скобки
// Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:

// // это вызовет синтаксическую ошибку
// user.likes birds = true
// JavaScript видит, что мы обращаемся к свойству user.likes, а затем идёт непонятное слово birds. В итоге синтаксическая ошибка.

// Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов,
// не начинался с цифры и не содержал специальные символы, кроме $ и _.

// Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:

// let user = {};

// // присваивание значения свойству
// user["likes birds"] = true;

// // получение значения свойства
// alert(user["likes birds"]); // true

// // удаление свойства
// delete user["likes birds"];

// Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения.
// Например, имя свойства может храниться в переменной:

// let key = "likes birds";

// // то же самое, что и user["likes birds"] = true;
// user[key] = true;

// Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода.
// После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.

// let user = {
//   name: "John",
//   age: 30
// };

// let key = prompt("Что вы хотите узнать о пользователе?", "name");

// // доступ к свойству через переменную
// alert( user[key] ); // John (если ввели "name")

// Вычисляемые свойства
// Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.

// Пример:

// let fruit = prompt("Какой фрукт купить?", "apple");

// let bag = {
//   [fruit]: 5, // имя свойства будет взято из переменной fruit
// };

// alert( bag.apple ); // 5, если fruit="apple"
// Смысл вычисляемого свойства прост: запись [fruit] означает, что имя свойства необходимо взять из переменной fruit.

// И если посетитель введёт слово "apple", то в объекте bag теперь будет лежать свойство {apple: 5}.
// Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку.
// Если же нам нужно что-то более сложное, то мы используем квадратные скобки.

// Проверка существования свойства, оператор «in»
// В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!

// При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства

// Также существует специальный оператор "in" для проверки существования свойства в объекте.

// Синтаксис оператора:

// "key" in object
// Пример:

// let user = { name: "John", age: 30 };

// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует

// Обратите внимание, что слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:

// let user = { age: 30 };

// let key = "age";
// alert( key in user ); // true, имя свойства было взято из переменной key

// Цикл «for…in»

// Для перебора всех свойств объекта используется цикл for..in. Этот цикл отличается от изученного ранее цикла for(;;).

// Синтаксис:

// for (key in object) {
//   // тело цикла выполняется для каждого свойства объекта
// }

// К примеру, давайте выведем все свойства объекта user:

// let user = {
//   name: "John",
//   age: 30,
//   isAdmin: true
// };

// for (let key in user) {
//   // ключи
//   alert( key );  // name, age, isAdmin
//   // значения ключей
//   alert( user[key] ); // John, 30, true
// }

// Упорядочение свойств объекта

// Упорядочены ли свойства объекта? Другими словами, если мы будем в цикле перебирать все свойства объекта, получим ли мы их в
// том же порядке, в котором мы их добавляли? Можем ли мы на это рассчитывать?

// Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные
// располагаются в порядке создания.

// Целочисленные свойства? Это что?
// Термин «целочисленное свойство» означает строку, которая может быть преобразована в целое число и обратно без изменений.

// То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку,
//  то оно не изменится. А вот свойства "+49" или "1.2" таковыми не являются:

//  let user = {
//   name: "John",
//   surname: "Smith"
// };
// user.age = 25; // добавим ещё одно свойство

// // не целочисленные свойства перечислены в порядке создания
// for (let prop in user) {
//   alert( prop ); // name, surname, age
// }

// Итого
// Объекты – это ассоциативные массивы с рядом дополнительных возможностей.

// Они хранят свойства (пары ключ-значение), где:

// Ключи свойств должны быть строками или символами (обычно строками).
// Значения могут быть любого типа.
// Чтобы получить доступ к свойству, мы можем использовать:

// Запись через точку: obj.property.
// Квадратные скобки obj["property"]. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].
// Дополнительные операторы:

// Удаление свойства: delete obj.prop.
// Проверка существования свойства: "key" in obj.
// Перебор свойств объекта: цикл for for (let key in obj).
// То, что мы изучали в этой главе, называется «простым объектом» («plain object») или просто Object.

// В JavaScript есть много других типов объектов:

// Array для хранения упорядоченных коллекций данных,
// Date для хранения информации о дате и времени,
// Error для хранения информации об ошибке.
// … и так далее.

// 4.2 Копирование объектов и ссылки

// Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».
// Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».

// Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.
// Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.

// Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

// Если мы представляем объект как ящик, то переменная – это ключ к нему. Копирование переменной дублирует ключ, но не сам ящик.

// Например:

// let user = { name: "Иван" };

// let admin = user; // копируется ссылка

// Сравнение по ссылке

// Два объекта равны только в том случае, если это один и тот же объект.
// Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы.

// Клонирование и объединение объектов, Object.assign

// метод Object.assign.

// et user = {
//   name: "Иван",
//   age: 30
// };

// let clone = {}; // новый пустой объект

// // скопируем все свойства user в него
// for (let key in user) {
//   clone[key] = user[key];
// }

// // теперь в переменной clone находится абсолютно независимый клон объекта
// clone.name = "Пётр"; // изменим в нём данные

// alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// Синтаксис:

// Object.assign(dest, [src1, src2, src3...])
// Первый аргумент dest — целевой объект.
// Остальные аргументы src1, ..., srcN (может быть столько, сколько нужно)) являются исходными объектами
// Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. То есть,
// свойства всех перечисленных объектов, начиная со второго, копируются в первый объект.
// Возвращает объект dest.
// Например, объединим несколько объектов в один:

// let user = { name: "Иван" };

// let permissions1 = { canView: true };
// let permissions2 = { canEdit: true };

// // копируем все свойства из permissions1 и permissions2 в user
// Object.assign(user, permissions1, permissions2);

// // теперь user = { name: "Иван", canView: true, canEdit: true }

// Если принимающий объект (user) уже имеет свойство с таким именем, оно будет перезаписано:

// Мы также можем использовать Object.assign для замены for..in на простое клонирование:

// let user = {
//   name: "Иван",
//   age: 30
// };

// let clone = Object.assign({}, user);
// Этот метод скопирует все свойства объекта user в пустой объект и возвратит его.

// Вложенное клонирование

// Итого
// Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта»,
//  а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в качестве аргумента
//   функции приводит к копированию этой ссылки, а не самого объекта.

// Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.

// Для «простого клонирования» объекта можно использовать Object.assign. Необходимо помнить, что Object.assign не делает глубокое клонирования
// объекта. Если внутри копируемого объекта есть свойство значение, которого не является примитивом, оно будет передано по ссылке.
// Для создания «настоящей копии» (полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки _.cloneDeep(obj).

// 4.3 Сборка мусора

// Достижимость
// Основной концепцией управления памятью в JavaScript является принцип достижимости.

// Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.

// Существует базовое множество достижимых значений, которые не могут быть удалены.

// Например:

// Локальные переменные и параметры текущей функции.
// Переменные и параметры других функций в текущей цепочке вложенных вызовов.
// Глобальные переменные.
// (некоторые другие внутренние значения)
// Эти значения мы будем называть корнями.

// Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.

// Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект,
// то этот объект считается достижимым. И те, на которые он ссылается, тоже достижимы.

// В интерпретаторе JavaScript есть фоновый процесс, который называется сборщик мусора. Он следит за всеми объектами
// и удаляет те, которые стали недостижимы.

// Простой пример
// Вот самый простой пример:

// // в user находится ссылка на объект
// let user = {
//   name: "John"
// };

// Здесь стрелка обозначает ссылку на объект. Глобальная переменная user ссылается на объект {name: "John"}
// (мы будем называть его просто «John»). В свойстве "name" объекта John хранится примитив, поэтому оно нарисовано внутри объекта.

// Если перезаписать значение user, то ссылка потеряется:

// user = null;

// Теперь объект John становится недостижимым. К нему нет доступа, на него нет ссылок. Сборщик мусора удалит эти данные и освободит память.

// Две ссылки
// Представим, что мы скопировали ссылку из user в admin:

// // в user находится ссылка на объект
// let user = {
//   name: "John"
// };

// let admin = user;

// Теперь, если мы сделаем то же самое:

// user = null;
// …то объект John всё ещё достижим через глобальную переменную admin, поэтому он находится в памяти. Если бы мы также
// перезаписали admin, то John был бы удалён.

// Внутренние алгоритмы
// Основной алгоритм сборки мусора – «алгоритм пометок» (англ. «mark-and-sweep»).

// Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:

// Сборщик мусора «помечает» (запоминает) все корневые объекты.
// Затем он идёт по их ссылкам и помечает все найденные объекты.
// Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются,
//  чтобы в будущем не посещать один и тот же объект дважды.
// …И так далее, пока не будут посещены все ссылки (достижимые от корней).
// Все непомеченные объекты удаляются.

// Вот некоторые из оптимизаций:

// Сборка по поколениям (Generational collection) – объекты делятся на «новые» и «старые». Многие объекты появляются, выполняют
// свою задачу и быстро умирают, их можно удалять более агрессивно. Те, которые живут достаточно долго, становятся «старыми» и проверяются реже.

// Инкрементальная сборка (Incremental collection) – если объектов много, то обход всех ссылок и пометка достижимых объектов может
// занять значительное время и привести к видимым задержкам выполнения скрипта. Поэтому интерпретатор пытается организовать сборку мусора
//  поэтапно. Этапы выполняются по отдельности один за другим. Это требует дополнительного учёта для отслеживания изменений между этапами,
//  но зато теперь у нас есть много крошечных задержек вместо одной большой.

// Сборка в свободное время (Idle-time collection) – чтобы уменьшить возможное влияние на производительность, сборщик
// мусора старается работать только во время простоя процессора.

// Итого
// Главное из того, что мы узнали:

// Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.
// Объекты сохраняются в памяти, пока они достижимы.
// Наличие ссылки не гарантирует, что объект достижим (от корня): несколько взаимосвязанных объектов могут стать недостижимыми как единое целое.

// 4.8 Преобразование объектов в примитивы

// Преобразование объектов в примитивы
// Что произойдёт, если сложить два объекта obj1 + obj2, вычесть один из другого obj1 - obj2 или вывести их на экран, воспользовавшись alert(obj)?

// В этом случае объекты сначала автоматически преобразуются в примитивы, а затем выполняется операция.

// Все объекты в логическом контексте являются true. Существуют лишь их численные и строковые преобразования.
// Численные преобразования происходят, когда мы вычитаем объекты или выполняем математические операции. Например,
// объекты Date (мы рассмотрим их в статье Дата и время) могут вычитаться, и результатом date1 - date2 будет временной отрезок между двумя датами.
// Что касается строковых преобразований – они обычно происходят, когда мы выводим объект alert(obj),
//  а также в других случаях, когда объект используется как строка.

//  Существуют три варианта преобразований («три хинта»), описанные в спецификации:

// "string"
// Для преобразования объекта к строке, когда операция ожидает получить строку, например alert:

// // вывод
// alert(obj);

// // используем объект в качестве имени свойства
// anotherObj[obj] = 123;
// "number"
// Для преобразования объекта к числу, в случае математических операций:

// // явное преобразование
// let num = Number(obj);

// // математическое (исключая бинарный оператор "+")
// let n = +obj; // унарный плюс
// let delta = date1 - date2;

// // сравнения больше/меньше
// let greater = user1 > user2;
// "default"
// Происходит редко, когда оператор «не уверен», какой тип ожидать.

// Например, бинарный плюс + может работать с обоими типами: строками (объединять их) и числами (складывать).
//  Таким образом, и те, и другие будут вычисляться. Или когда происходит сравнение объектов с помощью
//  нестрогого равенства == со строкой, числом или символом, и неясно, какое преобразование должно быть выполнено.

// // бинарный плюс
// let total = car1 + car2;

// // obj == string/number/symbol
// if (user == 1) { ... };

// Оператор больше/меньше <> также может работать как со строками, так и с числами. Однако, по историческим
// причинам он использует хинт «number», а не «default».

// На практике все встроенные объекты, исключая Date (мы познакомимся с ним чуть позже), реализуют "default"
// преобразования тем же способом, что и "number". И нам следует поступать так же.

// Обратите внимание, что существуют лишь три варианта хинтов. Всё настолько просто. Не существует хинта
// со значением «boolean» (все объекты являются true в логическом контексте) или каких-либо ещё. И если
// мы считаем "default" и "number" одинаковыми, как большинство встроенных объектов, то остаются всего два варианта преобразований.

// В процессе преобразования движок JavaScript пытается найти и вызвать три следующих метода объекта:

// Вызывает obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ),
//  если такой метод существует, и передаёт ему хинт.
// Иначе, если хинт равен "string"
// пытается вызвать obj.toString(), а если его нет, то obj.valueOf(), если он существует.
// В случае, если хинт равен "number" или "default"
// пытается вызвать obj.valueOf(), а если его нет, то obj.toString(), если он существует.

// Symbol.toPrimitive
// Начнём с универсального подхода – символа Symbol.toPrimitive: метод с таким названием (если есть) используется для всех преобразований:

// obj[Symbol.toPrimitive] = function(hint) {
//   // должен вернуть примитивное значение
//   // hint равно чему-то одному из: "string", "number" или "default"
// };
// Для примера используем его в реализации объекта user:

// let user = {
//   name: "John",
//   money: 1000,

//   [Symbol.toPrimitive](hint) {
//     alert(`hint: ${hint}`);
//     return hint == "string" ? `{name: "${this.name}"}` : this.money;
//   }
// };

// // демонстрация результатов преобразований:
// alert(user); // hint: string -> {name: "John"}
// alert(+user); // hint: number -> 1000
// alert(user + 500); // hint: default -> 1500
// Как мы видим из кода, user преобразовывается либо в информативную читаемую строку, либо в денежный счёт в
//  зависимости от значения хинта. Единственный метод user[Symbol.toPrimitive] смог обработать все случаи преобразований.

//  Методы toString/valueOf

//  Если нет метода Symbol.toPrimitive, движок JavaScript пытается найти эти методы и вызвать их следующим образом:

// toString -> valueOf для хинта со значением «string».
// valueOf -> toString – в ином случае.

// В отсутствие Symbol.toPrimitive и valueOf, toString обработает все случаи преобразований к примитивам.

// Возвращаемые типы

// Важно понимать, что все описанные методы для преобразований объектов не обязаны возвращать именно требуемый «хинтом» тип примитива.

// Нет обязательного требования, чтобы toString() возвращал именно строку, или чтобы
// метод Symbol.toPrimitive возвращал именно число для хинта «number».

// Единственное обязательное требование: методы должны возвращать примитив, а не объект.

// Историческая справка
// По историческим причинам, если toString или valueOf вернёт объект, то ошибки не будет, но такое значение
// будет проигнорировано (как если бы метода вообще не существовало).

// Метод Symbol.toPrimitive, напротив, обязан возвращать примитив, иначе будет ошибка.

// 5.1 Методы у примитивов

// JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами.
// У них есть и методы. Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

// Примитив

// Это – значение «примитивного» типа.
// Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint.

// Объект

// Может хранить множество значений как свойства.
// Объявляется при помощи фигурных скобок {}, например: {name: "Рома", age: 30}. В JavaScript есть и другие виды объектов:
// например, функции тоже являются объектами.

// Одна из лучших особенностей объектов – это то, что мы можем хранить функцию как одно из свойств объекта.

// Примитив как объект

// Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean и Symbol.
// Таким образом, они имеют разный набор методов.

// К примеру, существует метод str.toUpperCase(), который возвращает строку в верхнем регистре.

// Вот, как он работает:

// let str = "Привет";

// alert( str.toUpperCase() ); // ПРИВЕТ
// Очень просто, не правда ли? Вот, что на самом деле происходит в str.toUpperCase():

// Строка str – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает
// значение строки и имеет такие полезные методы, как toUpperCase().
// Этот метод запускается и возвращает новую строку (показывается в alert).
// Специальный объект удаляется, оставляя только примитив str.
// Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

// Конструкторы String/Number/Boolean предназначены только для внутреннего пользования

// Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при
// помощи такого синтаксиса как new Number(1) или new Boolean(false).

// В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых
// местах последствия могут быть катастрофическими.

// null/undefined не имеют методов
// Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов.
// В некотором смысле, они «самые примитивные».

// Итого
// Все примитивы, кроме null и undefined, предоставляют множество полезных методов. Мы познакомимся с ними поближе в следующих главах.
// Формально эти методы работают с помощью временных объектов, но движки JavaScript внутренне очень хорошо оптимизируют этот процесс,
// так что их вызов не требует много ресурсов.

// 5.2 Числа

// В современном JavaScript существует два типа чисел:

// Обычные числа в JavaScript хранятся в 64-битном формате IEEE-754, который также называют «числа с плавающей
// точкой двойной точности» (double precision floating point numbers). Это числа, которые мы будем использовать чаще всего.
// Мы поговорим о них в этой главе.

// BigInt числа дают возможность работать с целыми числами произвольной длины. Они нужны достаточно редко и используются
// в случаях, когда необходимо работать со значениями более чем 253 или менее чем -253. Так как BigInt числа нужны достаточно
// редко, мы рассмотрим их в отдельной главе BigInt.

// В JavaScript можно использовать букву "e", чтобы укоротить запись числа. Она добавляется к числу и заменяет указанное количество нулей:

// let billion = 1e9;

// Записать микросекунду в укороченном виде нам поможет "e".

// let ms = 1e-6; // шесть нулей, слева от 1

// toString(base)
// Метод num.toString(base) возвращает строковое представление числа num в системе счисления base.

// Например:

// let num = 255;

// alert( num.toString(16) );  // ff
// alert( num.toString(2) );   // 11111111
// base может варьироваться от 2 до 36 (по умолчанию 10).

// Часто используемые:

// base=16 — для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры могут быть 0..9 или A..F.

// base=2 — обычно используется для отладки побитовых операций, цифры 0 или 1.

// base=36 — максимальное основание, цифры могут быть 0..9 или A..Z. То есть, используется весь латинский алфавит для представления
// числа. Забавно, но можно использовать 36-разрядную систему счисления для получения короткого представления большого числового
// идентификатора. К примеру, для создания короткой ссылки. Для этого просто преобразуем его в 36-разрядную систему счисления:

// Округление
// Одна из часто используемых операций при работе с числами – это округление.

// В JavaScript есть несколько встроенных функций для работы с округлением:

// Math.floor
// Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
// Math.ceil
// Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
// Math.round
// Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.

// toFixed(n):
// let sum = 0.1 + 0.2;
// alert( sum.toFixed(2) ); // 0.30
// Помните, что метод toFixed всегда возвращает строку.

// Проверка: isFinite и isNaN
// Помните эти специальные числовые значения?

// Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
// NaN представляет ошибку.
// Эти числовые значения принадлежат типу number, но они не являются «обычными» числами, поэтому есть функции для их проверки:

// isNaN(value) преобразует значение в число и проверяет является ли оно NaN:

// alert( isNaN(NaN) ); // true
// alert( isNaN("str") ); // true

// значение NaN уникально тем, что оно не является равным ни чему другому, даже самому себе:

// isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity:

// alert( isFinite("15") ); // true
// alert( isFinite("str") ); // false, потому что специальное значение: NaN
// alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
// Иногда isFinite используется для проверки, содержится ли в строке число:

// let num = +prompt("Enter a number", '');

// // вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
// alert( isFinite(num) );

// Помните, что пустая строка интерпретируется как 0 во всех числовых функциях, включаяisFinite.

// Сравнение Object.is
// Существует специальный метод Object.is, который сравнивает значения примерно как ===, но более надёжен в двух особых ситуациях:

// Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
// Значения 0 и -0 разные: Object.is(0, -0) === false, это редко используется, но технически эти значения разные.
// Во всех других случаях Object.is(a, b) идентичен a === b.

// Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2
// значения на предмет точного совпадения, он использует Object.is (Определение SameValue).

// parseInt и parseFloat
// Для явного преобразования к числу можно использовать + или Number(). Если строка не является в точности числом, то результат будет NaN:

// alert( +"100px" ); // NaN

// В реальной жизни мы часто сталкиваемся со значениями у которых есть единица измерения, например "100px" или "12pt" в CSS.
// Также во множестве стран символ валюты записывается после номинала "19€". Так как нам получить числовое значение из таких строк?

// Для этого есть parseInt и parseFloat.

// Они «читают» число из строки. Если в процессе чтения возникает ошибка, они возвращают полученное до ошибки число. Функция parseInt
// возвращает целое число, а parseFloat возвращает число с плавающей точкой:

// Функции parseInt/parseFloat вернут NaN, если не смогли прочитать ни одну цифру:

// Второй аргумент parseInt(str, radix)
// Функция parseInt() имеет необязательный второй параметр. Он определяет систему счисления, таким образом parseInt может также
// читать строки с шестнадцатеричными числами, двоичными числами и т.д.:

// Другие математические функции

// Другие математические функции
// В JavaScript встроен объект Math, который содержит различные математические функции и константы.

// Несколько примеров:

// Math.random()
// Возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)

// alert( Math.random() ); // 0.1234567894322

// Math.max(a, b, c...) / Math.min(a, b, c...)
// Возвращает наибольшее/наименьшее число из перечисленных аргументов.

// alert( Math.max(3, 5, -10, 0, 1) ); // 5
// alert( Math.min(1, 2) ); // 1
// Math.pow(n, power)
// Возвращает число n, возведённое в степень power

// alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024

// Итого
// Чтобы писать числа с большим количеством нулей:

// Используйте краткую форму записи чисел – "e", с указанным количеством нулей. Например: 123e6 это 123 с 6-ю нулями 123000000.
// Отрицательное число после "e" приводит к делению числа на 1 с указанным количеством нулей. Например: 123e-6 это 0.000123 (123 миллионных).
// Для других систем счисления:

// Можно записывать числа сразу в шестнадцатеричной (0x), восьмеричной (0o) и бинарной (0b) системах счисления
// parseInt(str, base) преобразует строку в целое число в соответствии с указанной системой счисления: 2 ≤ base ≤ 36.
// num.toString(base) представляет число в строковом виде в указанной системе счисления base.
// Для преобразования значений типа 12pt и 100px в число:

// Используйте parseInt/parseFloat для «мягкого» преобразования строки в число, данные функции по порядку
//  считывают число из строки до тех пор пока не возникнет ошибка.
// Для дробей:

// Используйте округления Math.floor, Math.ceil, Math.trunc, Math.round или num.toFixed(precision).
// Помните, что при работе с дробями происходит потеря точности.

// 5.3

// Строки
// В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

// Внутренний формат для строк — всегда UTF-16, вне зависимости от кодировки страницы.

// Кавычки
// В JavaScript есть разные типы кавычек.

// Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

// let single = 'single-quoted';
// let double = "double-quoted";

// let backticks = `backticks`;

// Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку
//  мы сможем вставлять произвольные выражения, обернув их в ${…}: ${sum(1, 2)}

//  Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

// let guestList = `Guests:
//  * John
//  * Pete
//  * Mary
// `;

// alert(guestList); // список гостей, состоящий из нескольких строк

// Обратные кавычки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой.
// Используемый синтаксис: func`string`. Автоматически вызываемая функция func получает строку и встроенные в неё выражения и может их обработать.

// Спецсимволы

// Символ	Описание
// \n	Перевод строки
// \r	Возврат каретки: самостоятельно не используется. В текстовых файлах Windows для перевода строки используется комбинация символов \r\n.
// \', \"	Кавычки
// \\	Обратный слеш
// \t	Знак табуляции
// \b, \f, \v	Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.
// \xXX	Символ с шестнадцатеричным юникодным кодом XX, например, '\x7A' — то же самое, что 'z'.
// \uXXXX	Символ в кодировке UTF-16 с шестнадцатеричным кодом XXXX, например, \u00A9 — юникодное представление знака копирайта,
//  ©. Код должен состоять ровно из 4 шестнадцатеричных цифр.

//  Все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».

// Он также используется, если необходимо вставить в строку кавычку.

// К примеру:

// alert( 'I\'m the Walrus!' ); // I'm the Walrus!

// Здесь перед входящей в строку кавычкой необходимо добавить обратный слеш — \' — иначе она бы обозначала окончание строки.

// Разумеется, требование экранировать относится только к таким же кавычкам, как те, в которые заключена строка.
// Так что мы можем применить и более элегантное решение, использовав для этой строки двойные или обратные кавычки:

// alert( `I'm the Walrus!` ); // I'm the Walrus!

// Длина строки
// Свойство length содержит длину строки:

// alert( `My\n`.length ); // 3
// Обратите внимание, \n — это один спецсимвол, поэтому тут всё правильно: длина строки 3

// str.length — это числовое свойство, а не функция, добавлять скобки не нужно.

// Доступ к символам
// Получить символ, который занимает позицию pos, можно с помощью квадратных скобок: [pos]. Также
// можно использовать метод charAt: str.charAt(pos). Первый символ занимает нулевую позицию:

// let str = `Hello`;

// // получаем первый символ
// alert( str[0] ); // H
// alert( str.charAt(0) ); // H

// // получаем последний символ
// alert( str[str.length - 1] ); // o

// Разница только в том, что если символ с такой позицией отсутствует, тогда [] вернёт undefined, а charAt — пустую строку:

// Также можно перебрать строку посимвольно, используя for..of:

// for (let char of "Hello") {
//   alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т. д.)
// }

// Строки неизменяемы
// Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда.

// Изменение регистра
// Методы toLowerCase() и toUpperCase() меняют регистр символов:

// alert( 'Interface'.toUpperCase() ); // INTERFACE
// alert( 'Interface'.toLowerCase() ); // interface
// Если мы захотим перевести в нижний регистр какой-то конкретный символ:

// alert( 'Interface'[0].toLowerCase() ); // 'i'

// Поиск подстроки
// Существует несколько способов поиска подстроки.

// str.indexOf
// Первый метод — str.indexOf(substr, pos).

// Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение,
// либо -1 при отсутствии совпадений.

// Например:

// let str = 'Widget with id';

// alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
// alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру

// alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with

// При проверке indexOf в условии if есть небольшое неудобство. Такое условие не будет работать:

// let str = "Widget with id";

// if (str.indexOf("Widget")) {
//     alert("Совпадение есть"); // не работает
// }
// Мы ищем подстроку "Widget", и она здесь есть, прямо на позиции 0. Но alert не показывается, т. к. str.indexOf("Widget")
// возвращает 0, и if решает, что тест не пройден.

// Поэтому надо делать проверку на -1:

// includes, startsWith, endsWith
// Более современный метод str.includes(substr, pos) возвращает true, если в строке str есть подстрока substr, либо false, если нет.

// Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

// alert( "Widget with id".includes("Widget") ); // true

// alert( "Hello".includes("Bye") ); // false
// Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

// alert( "Midget".includes("id") ); // true
// alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой:

// alert( "Widget".startsWith("Wid") ); // true, "Wid" — начало "Widget"
// alert( "Widget".endsWith("get") ); // true, "get" — окончание "Widget"

// Получение подстроки
// В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.

// str.slice(start [, end])
// Возвращает часть строки от start до (не включая) end.

// Например:

// let str = "stringify";
// // 'strin', символы от 0 до 5 (не включая 5)
// alert( str.slice(0, 5) );
// // 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
// alert( str.slice(0, 1) );
// Если аргумент end отсутствует, slice возвращает символы до конца строки:

// let str = "stringify";
// alert( str.slice(2) ); // ringify, с позиции 2 и до конца
// Также для start/end можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с конца строки:

// let str = "stringify";

// // начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
// alert( str.slice(-4, -1) ); // gif
// str.substring(start [, end])
// Возвращает часть строки между start и end.

// Это — почти то же, что и slice, но можно задавать start больше end.

// Например:

// let str = "stringify";

// // для substring эти два примера — одинаковы
// alert( str.substring(2, 6) ); // "ring"
// alert( str.substring(6, 2) ); // "ring"

// // …но не для slice:
// alert( str.slice(2, 6) ); // "ring" (то же самое)
// alert( str.slice(6, 2) ); // "" (пустая строка)
// Отрицательные значения substring, в отличие от slice, не поддерживает, они интерпретируются как 0.

// str.substr(start [, length])
// Возвращает часть строки от start длины length.

// В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

// let str = "stringify";
// // ring, получаем 4 символа, начиная с позиции 2
// alert( str.substr(2, 4) );
// Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

// let str = "stringify";
// // gi, получаем 2 символа, начиная с позиции 4 с конца строки
// alert( str.substr(-4, 2) );
// Давайте подытожим, как работают эти методы, чтобы не запутаться:

// метод	выбирает…	отрицательные значения
// slice(start, end)	от start до end (не включая end)	можно передавать отрицательные значения
// substring(start, end)	между start и end	отрицательные значения равнозначны 0
// substr(start, length)	length символов, начиная от start	значение start может быть отрицательным

// Какой метод выбрать?
// Все эти методы эффективно выполняют задачу. Формально у метода substr есть небольшой недостаток: он описан не
// в собственно спецификации JavaScript, а в приложении к ней — Annex B. Это приложение описывает возможности языка
// для использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом окружении,
// отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.

// Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в
// принципе, можно запомнить только его.

// Сравнение строк
// Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

// Тем не менее, есть некоторые нюансы.

// Строчные буквы больше заглавных:

// alert( 'a' > 'Z' ); // true
// Буквы, имеющие диакритические знаки, идут «не по порядку»:

// alert( 'Österreich' > 'Zealand' ); // true

// Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код. Есть специальные методы,
// позволяющие получить символ по его коду и наоборот.

// str.codePointAt(pos)
// Возвращает код для символа, находящегося на позиции pos:

// // одна и та же буква в нижнем и верхнем регистре
// // будет иметь разные коды
// alert( "z".codePointAt(0) ); // 122

// Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

// Отрицательное число, если str меньше str2.
// Положительное число, если str больше str2.
// 0, если строки равны.
// Например:

// alert( 'Österreich'.localeCompare('Zealand') ); // -1
// У этого метода есть два дополнительных аргумента, которые указаны в документации. Первый позволяет указать язык
// (по умолчанию берётся из окружения) — от него зависит порядок букв. Второй — определить дополнительные правила,
// такие как чувствительность к регистру, а также следует ли учитывать различия между "a" и "á".

// Итого
// Есть три типа кавычек. Строки, использующие обратные кавычки, могут занимать более одной строки в коде и включать выражения ${…}.
// Строки в JavaScript кодируются в UTF-16.
// Есть специальные символы, такие как \n, и можно добавить символ по его юникодному коду, используя \u….
// Для получения символа используйте [].
// Для получения подстроки используйте slice или substring.
// Для того, чтобы перевести строку в нижний или верхний регистр, используйте toLowerCase/toUpperCase.
// Для поиска подстроки используйте indexOf или includes/startsWith/endsWith, когда надо только проверить, есть ли вхождение.
// Чтобы сравнить строки с учётом правил языка, используйте localeCompare.
// Строки также имеют ещё кое-какие полезные методы:

// str.trim() — убирает пробелы в начале и конце строки.
// str.repeat(n) — повторяет строку n раз.
// …и другие, которые вы можете найти в справочнике.

// 5.4

// Объекты позволяют хранить данные со строковыми ключами. Это замечательно.

// Но довольно часто мы понимаем, что нам необходима упорядоченная коллекция данных, в которой присутствуют 1-й, 2-й,
// 3-й элементы и т.д. Например, она понадобится нам для хранения списка чего-либо: пользователей, товаров, элементов HTML и т.д.

// В этом случае использовать объект неудобно, так как он не предоставляет методов управления порядком элементов.
// Мы не можем вставить новое свойство «между» уже существующими. Объекты просто не предназначены для этих целей.

// Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.

// Объявление
// Существует два варианта синтаксиса для создания пустого массива:

// let arr = new Array();
// let arr = [];

// Элементы массива нумеруются, начиная с нуля.

// Мы можем получить элемент, указав его номер в квадратных скобках:

// let fruits = ["Яблоко", "Апельсин", "Слива"];

// alert( fruits[0] ); // Яблоко
// alert( fruits[1] ); // Апельсин
// alert( fruits[2] ); // Слива

// Мы можем заменить элемент:

// fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
// …Или добавить новый к существующему массиву:

// fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
// Общее число элементов массива содержится в его свойстве length:

// В массиве могут храниться элементы любого типа.

// Висячая запятая
// Список элементов массива, как и список свойств объекта, может оканчиваться запятой:

// let fruits = [
//   "Яблоко",
//   "Апельсин",
//   "Слива",
// ];
// «Висячая запятая» упрощает процесс добавления/удаления элементов, так как все строки становятся идентичными.

// Методы pop/push, shift/unshift
// Очередь – один из самых распространённых вариантов применения массива. В области компьютерных наук так называется
//  упорядоченная коллекция элементов, поддерживающая два вида операций:

// push добавляет элемент в конец.
// shift удаляет элемент в начале, сдвигая очередь, так что второй элемент становится первым.

// Существует и другой вариант применения для массивов – структура данных, называемая стек.

// Она поддерживает два вида операций:

// push добавляет элемент в конец.
// pop удаляет последний элемент.
// Таким образом, новые элементы всегда добавляются или удаляются из «конца».

// Примером стека обычно служит колода карт: новые карты кладутся наверх и берутся тоже сверху:

// Массивы в JavaScript могут работать и как очередь, и как стек. Мы можем добавлять/удалять элементы как в начало, так и в конец массива.

// В компьютерных науках структура данных, делающая это возможным, называется двусторонняя очередь.

// Методы, работающие с концом массива:

// pop
// Удаляет последний элемент из массива и возвращает его:

// let fruits = ["Яблоко", "Апельсин", "Груша"];

// alert( fruits.pop() ); // удаляем "Груша" и выводим его

// alert( fruits ); // Яблоко, Апельсин
// push
// Добавляет элемент в конец массива:

// let fruits = ["Яблоко", "Апельсин"];

// fruits.push("Груша");

// alert( fruits ); // Яблоко, Апельсин, Груша
// Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....

// Методы, работающие с началом массива:

// shift
// Удаляет из массива первый элемент и возвращает его:

// let fruits = ["Яблоко", "Апельсин", "Груша"];

// alert( fruits.shift() ); // удаляем Яблоко и выводим его

// alert( fruits ); // Апельсин, Груша
// unshift
// Добавляет элемент в начало массива:

// let fruits = ["Апельсин", "Груша"];

// fruits.unshift('Яблоко');

// alert( fruits ); // Яблоко, Апельсин, Груша
// Методы push и unshift могут добавлять сразу несколько элементов:

// let fruits = ["Яблоко"];

// fruits.push("Апельсин", "Груша");
// fruits.unshift("Ананас", "Лимон");

// // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
// alert( fruits );

// Внутреннее устройство массива

// Внутреннее устройство массива
// Массив – это особый подвид объектов. Квадратные скобки, используемые для того, чтобы получить доступ к свойству arr[0] –
// это по сути обычный синтаксис доступа по ключу, как obj[key], где в роли obj у нас arr, а в качестве ключа – числовой индекс.

// Массивы расширяют объекты, так как предусматривают специальные методы для работы с упорядоченными коллекциями данных,
// а также свойство length. Но в основе всё равно лежит объект.

// Следует помнить, что в JavaScript существует 8 основных типов данных. Массив является объектом и, следовательно, ведёт себя как объект.

// Варианты неправильного применения массива:

// Добавление нечислового свойства, например: arr.test = 5.
// Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
// Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.
// Массив следует считать особой структурой, позволяющей работать с упорядоченными данными. Для этого массивы предоставляют
//  специальные методы. Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными,
//  поэтому, пожалуйста, используйте их именно в таких случаях. Если вам нужны произвольные ключи, вполне возможно, лучше
//   подойдёт обычный объект {}.

//   Эффективность
//   Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

//   Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.

//   То же самое происходит с unshift: чтобы добавить элемент в начало массива, нам нужно сначала сдвинуть существующие элементы вправо,
//    увеличивая их индексы.

// А что же с push/pop? Им не нужно ничего перемещать. Чтобы удалить элемент в конце массива, метод pop очищает индекс и уменьшает значение length.

// Действия при операции pop:

// fruits.pop(); // удаляем один элемент с конца

// Метод pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. Именно поэтому он выполняется очень быстро.

// Аналогично работает метод push.

// Перебор элементов
// Одним из самых старых способов перебора элементов массива является цикл for по цифровым индексам:

// let arr = ["Яблоко", "Апельсин", "Груша"];

// for (let i = 0; i < arr.length; i++) {
//   alert( arr[i] );
// }
// Но для массивов возможен и другой вариант цикла, for..of:

// let fruits = ["Яблоко", "Апельсин", "Слива"];

// // проходит по значениям
// for (let fruit of fruits) {
//   alert( fruit );
// }
// Цикл for..of не предоставляет доступа к номеру текущего элемента, только к его значению, но в
// большинстве случаев этого достаточно. А также это короче.

// Технически, так как массив является объектом, можно использовать и вариант for..in:

// let arr = ["Яблоко", "Апельсин", "Груша"];

// for (let key in arr) {
//   alert( arr[key] ); // Яблоко, Апельсин, Груша
// }
// Но на самом деле это – плохая идея. Существуют скрытые недостатки этого способа:

// Цикл for..in выполняет перебор всех свойств объекта, а не только цифровых.

// В браузере и других программных средах также существуют так называемые «псевдомассивы» – объекты, которые выглядят,
// как массив. То есть, у них есть свойство length и индексы, но они также могут иметь дополнительные нечисловые
// свойства и методы, которые нам обычно не нужны. Тем не менее, цикл for..in выведет и их. Поэтому, если нам
// приходится иметь дело с объектами, похожими на массив, такие «лишние» свойства могут стать проблемой.

// Цикл for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее. Увеличение
// скорости выполнения может иметь значение только при возникновении узких мест. Но мы всё же должны представлять разницу.

// В общем, не следует использовать цикл for..in для массивов.

// Немного о «length»
// Свойство length автоматически обновляется при изменении массива. Если быть точными, это не количество
// элементов массива, а наибольший цифровой индекс плюс один.

// Например, единственный элемент, имеющий большой индекс, даёт большую длину:

// самый простой способ очистить массив – это arr.length = 0;.

// new Array()
// Существует ещё один вариант синтаксиса для создания массива:

// let arr = new Array("Яблоко", "Груша", "и тд");
// Он редко применяется, так как квадратные скобки [] короче. Кроме того, у него есть хитрая особенность.

// Если new Array вызывается с одним аргументом, который представляет собой число, он создаёт массив без элементов, но с заданной длиной.

// Итого
// Массив – это особый тип объекта, предназначенный для работы с упорядоченным набором элементов.

// Объявление:

// // квадратные скобки (обычно)
// let arr = [item1, item2...];

// // new Array (очень редко)
// let arr = new Array(item1, item2...);
// Вызов new Array(number) создаёт массив с заданной длиной, но без элементов.

// Свойство length отражает длину массива или, если точнее, его последний цифровой индекс плюс один. Длина корректируется
// автоматически методами массива.

// Если мы уменьшаем length вручную, массив укорачивается.

// Мы можем использовать массив как двустороннюю очередь, используя следующие операции:

// push(...items)добавляет items в конец массива.
// pop() удаляет элемент в конце массива и возвращает его.
// shift() удаляет элемент в начале массива и возвращает его.
// unshift(...items) добавляет items в начало массива.
// Чтобы пройтись по элементам массива:

// for (let i=0; i<arr.length; i++) – работает быстрее всего, совместим со старыми браузерами.
// for (let item of arr) – современный синтаксис только для значений элементов (к индексам нет доступа).
// for (let i in arr) – никогда не используйте для массивов!

// 5.5 Методы массивов

// Массивы предоставляют множество методов. Чтобы было проще, в этой главе они разбиты на группы.

// Добавление/удаление элементов
// Мы уже знаем методы, которые добавляют и удаляют элементы из начала или конца:

// arr.push(...items) – добавляет элементы в конец,
// arr.pop() – извлекает элемент из конца,
// arr.shift() – извлекает элемент из начала,
// arr.unshift(...items) – добавляет элементы в начало.
// Есть и другие.

// Как удалить элемент из массива?

// Так как массивы – это объекты, то можно попробовать delete:

// let arr = ["I", "go", "home"];

// delete arr[1]; // удалить "go"

// alert( arr[1] ); // undefined

// // теперь arr = ["I",  , "home"];
// alert( arr.length ); // 3
// Вроде бы, элемент и был удалён, но при проверке оказывается, что массив всё ещё имеет 3 элемента arr.length == 3.

// Это нормально, потому что всё, что делает delete obj.key – это удаляет значение с данным ключом key. Это нормально для объектов,
// но для массивов мы обычно хотим, чтобы оставшиеся элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.

// Метод arr.splice(str) – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы.

// Его синтаксис:

// arr.splice(index[, deleteCount, elem1, ..., elemN])
// Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место. Возвращает массив из удалённых элементов.

// Этот метод проще всего понять, рассмотрев примеры.

// Начнём с удаления:

// let arr = ["Я", "изучаю", "JavaScript"];

// arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

// alert( arr ); // осталось ["Я", "JavaScript"]
// Легко, правда? Начиная с позиции 1, он убрал 1 элемент.

// В следующем примере мы удалим 3 элемента и заменим их двумя другими.

// let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// // удалить 3 первых элемента и заменить их другими
// arr.splice(0, 3, "Давай", "танцевать");

// alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// Здесь видно, что splice возвращает массив из удалённых элементов:

// let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// // удалить 2 первых элемента
// let removed = arr.splice(0, 2);

// alert( removed ); // "Я", "изучаю" <-- массив из удалённых элементов
// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:

// let arr = ["Я", "изучаю", "JavaScript"];

// // с позиции 2
// // удалить 0 элементов
// // вставить "сложный", "язык"
// arr.splice(2, 0, "сложный", "язык");

// alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

// Отрицательные индексы разрешены
// В этом и в других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчёт элементов с конца, как тут:

// let arr = [1, 2, 5];

// // начиная с индекса -1 (перед последним элементом)
// // удалить 0 элементов,
// // затем вставить числа 3 и 4
// arr.splice(-1, 0, 3, 4);

// alert( arr ); // 1,2,3,4,5

// Метод arr.slice намного проще, чем похожий на него arr.splice.

// Его синтаксис:

// arr.slice([start], [end])
// Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
// Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.

// Это похоже на строковый метод str.slice, но вместо подстрок возвращает подмассивы.

// Например:

// let arr = ["t", "e", "s", "t"];

// alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

// alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
// Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr. Это часто используют,
//  чтобы создать копию массива для дальнейших преобразований, которые не должны менять исходный массив.

//  concat
// Метод arr.concat создаёт новый массив, в который копирует данные из других массивов и дополнительные значения.

// Его синтаксис:

// arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.

// В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…

// Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

// Например:

// let arr = [1, 2];

// // создать массив из: arr и [3,4]
// alert( arr.concat([3, 4]) ); // 1,2,3,4

// // создать массив из: arr и [3,4] и [5,6]
// alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// // создать массив из: arr и [3,4], потом добавить значения 5 и 6
// alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

// Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть:

// let arr = [1, 2];

// let arrayLike = {
//   0: "что-то",
//   length: 1
// };

// alert( arr.concat(arrayLike) ); // 1,2,[object Object]
// …Но если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается concat как массив:
// вместо него добавляются его числовые свойства.

// Для корректной обработки в объекте должны быть числовые свойства и length:

// let arr = [1, 2];

// let arrayLike = {
//   0: "что-то",
//   1: "ещё",
//   [Symbol.isConcatSpreadable]: true,
//   length: 2
// };

// alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё

// Перебор: forEach
// Метод arr.forEach позволяет запускать функцию для каждого элемента массива.

// Его синтаксис:

// arr.forEach(function(item, index, array) {
//   // ... делать что-то с item
// });
// Например, этот код выведет на экран каждый элемент массива:

// // Вызов alert для каждого элемента
// ["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
// А этот вдобавок расскажет и о своей позиции в массиве:

// ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
//   alert(`${item} имеет позицию ${index} в ${array}`);
// });
// Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.

// indexOf/lastIndexOf и includes
// Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое, что и их строковые аналоги,
//  но работают с элементами вместо символов:

// arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
// arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
// arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
// Например:

// let arr = [1, 0, false];

// alert( arr.indexOf(0) ); // 1
// alert( arr.indexOf(false) ); // 2
// alert( arr.indexOf(null) ); // -1

// alert( arr.includes(1) ); // true
// Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.

// Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является arr.includes.

// Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

// const arr = [NaN];
// alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
// alert( arr.includes(NaN) );// true (верно)

// Поиск в массиве
// Далее рассмотрим методы, которые помогут найти что-нибудь в массиве.

// indexOf/lastIndexOf и includes
// Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути то же самое,
// что и их строковые аналоги, но работают с элементами вместо символов:

// arr.indexOf(item, from) ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый элемент, в противном случае -1.
// arr.lastIndexOf(item, from) – то же самое, но ищет справа налево.
// arr.includes(item, from) – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
// Например:

// let arr = [1, 0, false];

// alert( arr.indexOf(0) ); // 1
// alert( arr.indexOf(false) ); // 2
// alert( arr.indexOf(null) ); // -1

// alert( arr.includes(1) ); // true

// Обратите внимание, что методы используют строгое сравнение ===. Таким образом, если мы ищем false, он находит именно false, а не ноль.

// Если мы хотим проверить наличие элемента, и нет необходимости знать его точный индекс, тогда предпочтительным является arr.includes.

// Кроме того, очень незначительным отличием includes является то, что он правильно обрабатывает NaN в отличие от indexOf/lastIndexOf:

// const arr = [NaN];
// alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
// alert( arr.includes(NaN) );// true (верно)

// Функция вызывается по очереди для каждого элемента массива:

// item – очередной элемент.
// index – его индекс.
// array – сам массив.
// Если функция возвращает true, поиск прерывается и возвращается item. Если ничего не найдено, возвращается undefined.

// Например, у нас есть массив пользователей, каждый из которых имеет поля id и name. Попробуем найти того, кто с id == 1:

// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// let user = users.find(item => item.id == 1);

// alert(user.name); // Вася
// В реальной жизни массивы объектов – обычное дело, поэтому метод find крайне полезен.

// Обратите внимание, что в данном примере мы передаём find функцию item => item.id == 1, с одним аргументом. Это типично,
// дополнительные аргументы этой функции используются редко.

// Метод arr.findIndex – по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1,
// если ничего не найдено.

// filter
// Метод find ищет один (первый попавшийся) элемент, на котором функция-колбэк вернёт true.

// На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).

// Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:

// let results = arr.filter(function(item, index, array) {
//   // если true - элемент добавляется к результату, и перебор продолжается
//   // возвращается пустой массив в случае, если ничего не найдено
// });
// Например:

// let users = [
//   {id: 1, name: "Вася"},
//   {id: 2, name: "Петя"},
//   {id: 3, name: "Маша"}
// ];

// // возвращает массив, состоящий из двух первых пользователей
// let someUsers = users.filter(item => item.id < 3);

// alert(someUsers.length); // 2

// Преобразование массива
// Перейдём к методам преобразования и упорядочения массива.

// map
// Метод arr.map является одним из наиболее полезных и часто используемых.

// Он вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции.

// Синтаксис:

// let result = arr.map(function(item, index, array) {
//   // возвращается новое значение вместо элемента
// });
// Например, здесь мы преобразуем каждый элемент в его длину:

// let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
// alert(lengths); // 5,7,6

// sort(fn)
// Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.

// Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.

// Например:

// let arr = [ 1, 2, 15 ];

// // метод сортирует содержимое arr
// arr.sort();

// alert( arr );  // 1, 15, 2
// Не заметили ничего странного в этом примере?

// Порядок стал 1, 15, 2. Это неправильно! Но почему?

// По умолчанию элементы сортируются как строки.

// Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок,
//  и действительно выходит, что "2" > "15".

// Чтобы использовать наш собственный порядок сортировки, нам нужно предоставить функцию в качестве аргумента arr.sort().

// Функция должна для пары значений возвращать:

// function compare(a, b) {
//   if (a > b) return 1; // если первое значение больше второго
//   if (a == b) return 0; // если равны
//   if (a < b) return -1; // если первое значение меньше второго
// }
// Например, для сортировки чисел:

// function compareNumeric(a, b) {
//   if (a > b) return 1;
//   if (a == b) return 0;
//   if (a < b) return -1;
// }

// let arr = [ 1, 2, 15 ];

// arr.sort(compareNumeric);

// alert(arr);  // 1, 2, 15
// Теперь всё работает как надо.

// Давайте возьмём паузу и подумаем, что же происходит. Упомянутый ранее массив arr может быть массивом чего угодно, верно?
// Он может содержать числа, строки, объекты или что-то ещё. У нас есть набор каких-то элементов. Чтобы отсортировать его, нам нужна
//  функция, определяющая порядок, которая знает, как сравнивать его элементы. По умолчанию элементы сортируются как строки.

// Метод arr.sort(fn) реализует общий алгоритм сортировки. Нам не нужно заботиться о том, как он работает внутри (в большинстве случаев
//     это оптимизированная быстрая сортировка). Она проходится по массиву, сравнивает его элементы с помощью предоставленной функции и
//      переупорядочивает их. Всё, что остаётся нам, это предоставить fn, которая делает это сравнение.

// Кстати, если мы когда-нибудь захотим узнать, какие элементы сравниваются – ничто не мешает нам вывести их на экран:

// [1, -2, 15, 2, 0, 8].sort(function(a, b) {
//   alert( a + " <> " + b );
// });
// В процессе работы алгоритм может сравнивать элемент с другими по нескольку раз, но он старается сделать как можно меньше сравнений.

// Функция сравнения может вернуть любое число
// На самом деле от функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».

// Это позволяет писать более короткие функции:

// let arr = [ 1, 2, 15 ];

// arr.sort(function(a, b) { return a - b; });

// alert(arr);  // 1, 2, 15
// Лучше использовать стрелочные функции
// Помните стрелочные функции? Можно использовать их здесь для того, чтобы сортировка выглядела более аккуратной:

// arr.sort( (a, b) => a - b );
// Будет работать точно так же, как и более длинная версия выше.

// reverse
// Метод arr.reverse меняет порядок элементов в arr на обратный.

// Например:

// let arr = [1, 2, 3, 4, 5];
// arr.reverse();

// alert( arr ); // 5,4,3,2,1
// Он также возвращает массив arr с изменённым порядком элементов.

// split и join
// Ситуация из реальной жизни. Мы пишем приложение для обмена сообщениями, и посетитель вводит имена тех, кому его отправить,
// через запятую: Вася, Петя, Маша. Но нам-то гораздо удобнее работать с массивом имён, чем с одной строкой. Как его получить?

// Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.

// В примере ниже таким разделителем является строка из запятой и пробела.

// let names = 'Вася, Петя, Маша';

// let arr = names.split(', ');

// for (let name of arr) {
//   alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
// }
// У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их
// больше, чем указано, то остаток массива будет отброшен. На практике это редко используется:

// let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

// alert(arr); // Вася, Петя
// Разбивка по буквам
// Вызов split(s) с пустым аргументом s разбил бы строку на массив букв:

// let str = "тест";

// alert( str.split('') ); // т,е,с,т
// Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.

// Например:

// let arr = ['Вася', 'Петя', 'Маша'];

// let str = arr.join(';'); // объединить массив в строку через ;

// alert( str ); // Вася;Петя;Маша

// reduce/reduceRight
// Если нам нужно перебрать массив – мы можем использовать forEach, for или for..of.

// Если нам нужно перебрать массив и вернуть данные для каждого элемента – мы используем map.

// Вызов arr.join(glue) делает в точности противоположное split. Он создаёт строку из элементов arr, вставляя glue между ними.

// Например:
// let arr = ['Вася', 'Петя', 'Маша'];
// let str = arr.join(';'); // объединить массив в строку через ;
// alert( str ); // Вася;Петя;Маша

// Методы arr.reduce и arr.reduceRight похожи на методы выше, но они немного сложнее. Они используются для вычисления какого-нибудь единого значения на основе всего массива.

// Синтаксис:

// let value = arr.reduce(function(previousValue, item, index, array) {
//   // ...
// }, [initial]);
// Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

// Аргументы:

// previousValue – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.
// При вызове функции результат её вызова на предыдущем элементе массива передаётся как первый аргумент.

// Звучит сложновато, но всё становится проще, если думать о первом аргументе как «аккумулирующем» результат предыдущих вызовов функции. По окончании он становится результатом reduce.

// Этот метод проще всего понять на примере.

// Тут мы получим сумму всех элементов массива всего одной строкой:

// let arr = [1, 2, 3, 4, 5];

// let result = arr.reduce((sum, current) => sum + current, 0);

// alert(result); // 15
// Здесь мы использовали наиболее распространённый вариант reduce, который использует только 2 аргумента.

// Давайте детальнее разберём, как он работает.

// При первом запуске sum равен initial (последний аргумент reduce), то есть 0, а current – первый элемент массива, равный 1. Таким образом, результат функции равен 1.
// При втором запуске sum = 1, и к нему мы добавляем второй элемент массива (2).
// При третьем запуске sum = 3, к которому мы добавляем следующий элемент, и так далее…
// Поток вычислений получается такой:

// В виде таблицы, где каждая строка –- вызов функции на очередном элементе массива:

// sum	current	result
// первый вызов	0	1	1
// второй вызов	1	2	3
// третий вызов	3	3	6
// четвёртый вызов	6	4	10
// пятый вызов	10	5	15
// Здесь отчётливо видно, как результат предыдущего вызова передаётся в первый аргумент следующего.

// Мы также можем опустить начальное значение:

// let arr = [1, 2, 3, 4, 5];

// // убрано начальное значение (нет 0 в конце)
// let result = arr.reduce((sum, current) => sum + current);

// alert( result ); // 15
// Результат – точно такой же! Это потому, что при отсутствии initial в качестве первого значения
// берётся первый элемент массива, а перебор стартует со второго.

// Таблица вычислений будет такая же за вычетом первой строки.

// Но такое использование требует крайней осторожности. Если массив пуст, то вызов reduce без начального значения выдаст ошибку.

// Вот пример:

// let arr = [];

// // Error: Reduce of empty array with no initial value
// // если бы существовало начальное значение, reduce вернул бы его для пустого массива.
// arr.reduce((sum, current) => sum + current);
// Поэтому рекомендуется всегда указывать начальное значение.

// Метод arr.reduceRight работает аналогично, но проходит по массиву справа налево.

// Array.isArray
// Массивы не образуют отдельный тип языка. Они основаны на объектах.

// Поэтому typeof не может отличить простой объект от массива:

// alert(typeof {}); // object
// alert(typeof []); // тоже object
// …Но массивы используются настолько часто, что для этого придумали специальный метод: Array.isArray(value).
// Он возвращает true, если value массив, и false, если нет.

// alert(Array.isArray({})); // false

// alert(Array.isArray([])); // true

// Большинство методов поддерживают «thisArg»
// Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg.

// Этот параметр не объяснялся выше, так как очень редко используется, но для наиболее полного понимания темы мы обязаны его рассмотреть.

// Вот полный синтаксис этих методов:

// arr.find(func, thisArg);
// arr.filter(func, thisArg);
// arr.map(func, thisArg);
// // ...
// // thisArg - это необязательный последний аргумент
// Значение параметра thisArg становится this для func.

// Например, вот тут мы используем метод объекта army как фильтр, и thisArg передаёт ему контекст:

// let army = {
//   minAge: 18,
//   maxAge: 27,
//   canJoin(user) {
//     return user.age >= this.minAge && user.age < this.maxAge;
//   }
// };

// let users = [
//   {age: 16},
//   {age: 20},
//   {age: 23},
//   {age: 30}
// ];

// // найти пользователей, для которых army.canJoin возвращает true
// let soldiers = users.filter(army.canJoin, army);

// alert(soldiers.length); // 2
// alert(soldiers[0].age); // 20
// alert(soldiers[1].age); // 23
// Если бы мы в примере выше использовали просто users.filter(army.canJoin), то вызов army.canJoin был бы в режиме отдельной функции,
// с this=undefined. Это тут же привело бы к ошибке.

// Вызов users.filter(army.canJoin, army) можно заменить на users.filter(user => army.canJoin(user)), который делает
// то же самое. Последняя запись используется даже чаще, так как функция-стрелка более наглядна.

// Итого
// Шпаргалка по методам массива:

// Для добавления/удаления элементов:

// push (...items) – добавляет элементы в конец,
// pop() – извлекает элемент с конца,
// shift() – извлекает элемент с начала,
// unshift(...items) – добавляет элементы в начало.
// splice(pos, deleteCount, ...items) – начиная с индекса pos, удаляет deleteCount элементов и вставляет items.
// slice(start, end) – создаёт новый массив, копируя в него элементы с позиции start до end (не включая end).
// concat(...items) – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является
//  массивом, тогда берутся его элементы.
// Для поиска среди элементов:

// indexOf/lastIndexOf(item, pos) – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
// includes(value) – возвращает true, если в массиве имеется элемент value, в противном случае false.
// find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
// findIndex похож на find, но возвращает индекс вместо значения.
// Для перебора элементов:

// forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.
// Для преобразования массива:

// map(func) – создаёт новый массив из результатов вызова func для каждого элемента.
// sort(func) – сортирует массив «на месте», а потом возвращает его.
// reverse() – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
// split/join – преобразует строку в массив и обратно.
// reduce(func, initial) – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный
// результат между вызовами.
// Дополнительно:

// Array.isArray(arr) проверяет, является ли arr массивом.
// Обратите внимание, что методы sort, reverse и splice изменяют исходный массив.

// Изученных нами методов достаточно в 99% случаев, но существуют и другие.

// arr.some(fn)/arr.every(fn) проверяет массив.

// Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true,
// то метод возвращает true, иначе false.

// arr.fill(value, start, end) – заполняет массив повторяющимися value, начиная с индекса start до end.

// arr.copyWithin(target, start, end) – копирует свои элементы, начиная со start и заканчивая end, в собственную позицию target
// (перезаписывает существующие).

// Задача 1,2,4,5, ,10,11,12

// function sortByAge(arr) {
//   arr.sort((a, b) => (a.age < b.age ? 1 : -1));
// }

// let vasya = { name: "Вася", age: 25 };
// let petya = { name: "Петя", age: 30 };
// let masha = { name: "Маша", age: 28 };

// let arr = [vasya, petya, masha];

// sortByAge(arr);

// // теперь отсортировано: [vasya, masha, petya]
// alert(arr[0].name); // Вася
// alert(arr[1].name); // Маша
// alert(arr[2].name); // Петя

// 5.9 Object.keys, values, entries

// Методы поддерживаются для структур:

// Map
// Set
// Array
// Простые объекты также можно перебирать похожими методами, но синтаксис немного отличается.

// Object.keys, values, entries
// Для простых объектов доступны следующие методы:

// Object.keys(obj) – возвращает массив ключей.
// Object.values(obj) – возвращает массив значений.
// Object.entries(obj) – возвращает массив пар [ключ, значение].
// Обратите внимание на различия (по сравнению с map, например):

// Map	Object
// Синтаксис вызова	map.keys()	Object.keys(obj), не obj.keys()
// Возвращает	перебираемый объект	«реальный» массив

// Первое отличие в том, что мы должны вызвать Object.keys(obj), а не obj.keys().

// Почему так? Основная причина – гибкость. Помните, что объекты являются основой всех сложных структур в JavaScript.
// У нас может быть объект data, который реализует свой собственный метод data.values(). И мы всё ещё можем применять
// к нему стандартный метод Object.values(data).

// Второе отличие в том, что методы вида Object.* возвращают «реальные» массивы, а не просто итерируемые объекты. Это в
//  основном по историческим причинам.

// Например:

// let user = {
//   name: "John",
//   age: 30
// };
// Object.keys(user) = ["name", "age"]
// Object.values(user) = ["John", 30]
// Object.entries(user) = [ ["name","John"], ["age",30] ]
// Вот пример использования Object.values ​​для перебора значений свойств в цикле:

// let user = {
//   name: "John",
//   age: 30
// };

// // перебор значений
// for (let value of Object.values(user)) {
//   alert(value); // John, затем 30
// }

// Object.keys/values/entries игнорируют символьные свойства
// Так же, как и цикл for..in, эти методы игнорируют свойства, использующие Symbol(...) в качестве ключей.

// Обычно это удобно. Но если требуется учитывать и символьные ключи, то для этого существует отдельный метод
// Object.getOwnPropertySymbols, возвращающий массив только символьных ключей. Также, существует метод Reflect.ownKeys(obj),
// который возвращает все ключи.

// Трансформации объекта
// У объектов нет множества методов, которые есть в массивах, например map, filter и других.

// Если мы хотели бы их применить, то можно использовать Object.entries с последующим вызовом Object.fromEntries:

// Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.
// На нём вызываем методы массива, например, map.
// Используем Object.fromEntries(array) на результате, чтобы преобразовать его обратно в объект.
// Например, у нас есть объект с ценами, и мы хотели бы их удвоить:

// let prices = {
//   banana: 1,
//   orange: 2,
//   meat: 4,
// };

// let doublePrices = Object.fromEntries(
//   // преобразовать в массив, затем map, затем fromEntries обратно объект
//   Object.entries(prices).map(([key, value]) => [key, value * 2])
// );

// alert(doublePrices.meat); // 8
// Это может выглядеть сложным на первый взгляд, но становится лёгким для понимания после нескольких раз использования.

// Можно делать и более сложные «однострочные» преобразования таким путём. Важно только сохранять баланс,
// чтобы код при этом был достаточно простым для понимания.

// function sumSalaries(salaries) {

//   let sum = 0;
//   for (let salary of Object.values(salaries)) {
//     sum += salary;
//   }

//   return sum; // 650
// }

// let salaries = {
//   "John": 100,
//   "Pete": 300,
//   "Mary": 250
// };

// alert( sumSalaries(salaries) ); // 650

// Деструктурирующее присваивание
// В JavaScript есть две чаще всего используемые структуры данных – это Object и Array.

// Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам,
//  а массивы – хранить упорядоченные коллекции данных.

// Но когда мы передаём их в функцию, то ей может понадобиться не объект/массив целиком, а элементы по отдельности.

// Деструктурирующее присваивание – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных,
// так как иногда они более удобны. Деструктуризация также прекрасно работает со сложными функциями,
// которые имеют много параметров, значений по умолчанию и так далее.

// Деструктуризация массива
// Пример деструктуризации массива:

// // у нас есть массив с именем и фамилией
// let arr = ["Ilya", "Kantor"]

// // деструктурирующее присваивание
// // записывает firstName=arr[0], surname=arr[1]
// let [firstName, surname] = arr;

// alert(firstName); // Ilya
// alert(surname);  // Kantor
// Теперь мы можем использовать переменные вместо элементов массива.

// Отлично смотрится в сочетании со split или другими методами, возвращающими массив:

// let [firstName, surname] = "Ilya Kantor".split(' ');
// «Деструктуризация» не означает «разрушение».
// «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания,
// его задача – только скопировать нужные значения в переменные.

// Это просто короткий вариант записи:

// // let [firstName, surname] = arr;
// let firstName = arr[0];
// let surname = arr[1];
// Пропускайте элементы, используя запятые
// Ненужные элементы массива также могут быть отброшены через запятую:

// // второй элемент не нужен
// let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert( title ); // Consul
// В примере выше второй элемент массива пропускается, а третий присваивается переменной title, оставшиеся элементы
// массива также пропускаются (так как для них нет переменных).

// Работает с любым перебираемым объектом с правой стороны
// …На самом деле мы можем использовать любой перебираемый объект, не только массивы:

// let [a, b, c] = "abc";
// let [one, two, three] = new Set([1, 2, 3]);
// Присваивайте чему угодно с левой стороны
// Мы можем использовать что угодно «присваивающее» с левой стороны.

// Например, можно присвоить свойству объекта:

// let user = {};
// [user.name, user.surname] = "Ilya Kantor".split(' ');
// alert(user.name); // Ilya

// икл с .entries()
// В предыдущей главе мы видели метод Object.entries(obj).

// Мы можем использовать его с деструктуризацией для цикличного перебора ключей и значений объекта:

// let user = {
//   name: "John",
//   age: 30
// };

// // цикл по ключам и значениям
// for (let [key, value] of Object.entries(user)) {
//   alert(`${key}:${value}`); // name:John, затем age:30
// }
// …то же самое для map:

// let user = new Map();
// user.set("name", "John");
// user.set("age", "30");

// for (let [key, value] of user) {
//   alert(`${key}:${value}`); // name:John, затем age:30
// }
// Остаточные параметры «…»
// Если мы хотим не просто получить первые значения, но и собрать все остальные, то мы можем
//  добавить ещё один параметр, который получает остальные значения, используя оператор «остаточные параметры» – троеточие ("..."):

// let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// alert(name1); // Julius
// alert(name2); // Caesar

// // Обратите внимание, что `rest` является массивом.
// alert(rest[0]); // Consul
// alert(rest[1]); // of the Roman Republic
// alert(rest.length); // 2
// Переменная rest является массивом из оставшихся элементов. Вместо rest можно использовать любое
//  другое название переменной, просто убедитесь, что перед переменной есть три точки и она стоит на
//   последнем месте в деструктурирующем присваивании.

// Значения по умолчанию
// Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределёнными:

// let [firstName, surname] = [];

// alert(firstName); // undefined
// alert(surname); // undefined
// Если нам необходимо указать значения по умолчанию, то мы можем использовать =:

// // значения по умолчанию
// let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// alert(name);    // Julius (из массива)
// alert(surname); // Anonymous (значение по умолчанию)
// Значения по умолчанию могут быть гораздо более сложными выражениями или даже функциями. Они выполняются, только если значения отсутствуют.

// Например, здесь мы используем функцию prompt для указания двух значений по умолчанию.
//  Но она будет запущена только для отсутствующего значения:

// // prompt запустится только для surname
// let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];

// alert(name);    // Julius (из массива)
// alert(surname); // результат prompt

// Деструктуризация объекта
// Деструктурирующее присваивание также работает с объектами.

// Синтаксис:

// let {var1, var2} = {var1:…, var2:…}
// У нас есть существующий объект с правой стороны, который мы хотим разделить на переменные. Левая сторона содержит «шаблон»
// для соответствующих свойств. В простом случае это список названий переменных в {...}.

// Например:

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// let {title, width, height} = options;

// alert(title);  // Menu
// alert(width);  // 100
// alert(height); // 200
// Свойства options.title, options.width и options.height присваиваются соответствующим переменным. Порядок не имеет значения.
// Вот так – тоже работает:

// // изменён порядок в let {...}
// let {height, width, title} = { title: "Menu", height: 200, width: 100 }\

// Если мы хотим присвоить свойство объекта переменной с другим названием, например, свойство options.width присвоить переменной w,
// то мы можем использовать двоеточие:

// let options = {
//   title: "Menu",
//   width: 100,
//   height: 200
// };

// // { sourceProperty: targetVariable }
// let {width: w, height: h, title} = options;

// // width -> w
// // height -> h
// // title -> title

// alert(title);  // Menu
// alert(w);      // 100
// alert(h);      // 200

// Остаток объекта «…»

// Что если в объекте больше свойств, чем у нас переменных? Можем ли мы взять необходимые нам, а остальные присвоить куда-нибудь?
// Можно использовать троеточие, как и для массивов. В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.
// Выглядит так:

// let options = {
//   title: "Menu",
//   height: 200,
//   width: 100
// };

// // title = свойство с именем title
// // rest = объект с остальными свойствами
// let {title, ...rest} = options;

// // сейчас title="Menu", rest={height: 200, width: 100}
// alert(rest.height);  // 200
// alert(rest.width);   // 100

// Итого
// Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

// Полный синтаксис для объекта:

// let {prop : varName = default, ...rest} = object
// Свойства, которые не были упомянуты, копируются в объект rest.

// Полный синтаксис для массива:

// let [item1 = default, item2, ...rest] = array
// Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.

// Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.

// 5.11 Дата и время

// объект: Date. Он содержит дату и время, а также предоставляет методы управления ими.
// его можно использовать для хранения времени создания/изменения, для измерения времени или просто для вывода текущей даты.

// let now = new Date();
// alert( now ); // показывает текущие дату и время

// new Date(year, month, date, hours, minutes, seconds, ms)
// year должен состоять из четырёх цифр: значение 2013 корректно, 98 – нет.
// month начинается с 0 (январь) по 11 (декабрь).
// Параметр date здесь представляет собой день месяца. Если параметр не задан, то принимается значение 1.
// Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.

// Получение компонентов даты
// Существуют методы получения года, месяца и т.д. из объекта Date:

// getFullYear()
// Получить год (4 цифры)
// getMonth()
// Получить месяц, от 0 до 11.
// getDate()
// Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
// getHours(), getMinutes(), getSeconds(), getMilliseconds()
// Получить, соответственно, часы, минуты, секунды или миллисекунды.
// getDay()
// Вернуть день недели от 0 (воскресенье) до 6 (суббота).
// getTime()
// Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
// getTimezoneOffset()
// Возвращает разницу в минутах между местным часовым поясом и UTC:

// Никакого getYear(). Только getFullYear()

// Установка компонентов даты
// Следующие методы позволяют установить компоненты даты и времени:

// setFullYear(year, [month], [date])
// setMonth(month, [date])
// setDate(date)
// setHours(hour, [min], [sec], [ms])
// setMinutes(min, [sec], [ms])
// setSeconds(sec, [ms])
// setMilliseconds(ms)
// setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC)
// У всех этих методов, кроме setTime(), есть UTC-вариант, например: setUTCHours().

// Автоисправление даты
// Автоисправление – это очень полезная особенность объектов Date.

// Date.now() ( текущая метка времени)
// Если нужно просто измерить время, объект Date нам не нужен.

// Бенчмаркинг
// вычисления, замеряющие производительность, также называют «бенчмарками» (benchmark).

// Метод Date.parse(str) считывает дату из строки.

// Итого
// Дата и время в JavaScript представлены объектом Date. Нельзя создать «только дату» или «только время»: объекты Date всегда содержат и то,
//  и другое.
// Счёт месяцев начинается с нуля (да, январь – это нулевой месяц).
// Дни недели в getDay() также отсчитываются с нуля, что соответствует воскресенью.
// Объект Date самостоятельно корректируется при введении значений, выходящих за рамки допустимых. Это полезно для сложения/вычитания
// дней/месяцев/недель.
// Даты можно вычитать, и разность возвращается в миллисекундах. Так происходит, потому что при преобразовании в число объект
// Date становится таймстампом.
// Используйте Date.now() для быстрого получения текущего времени в формате таймстампа.

// EX 1
// let date = new Date(2012, 1, 20, 3, 12);
// alert(date);

// EX 2
// let date = new Date(2012, 0, 3); // 3 января 2012 года
// alert(getLocalDay(date)); // вторник, нужно показать 2
// function getLocalDay(date) {
//   let day = date.getDay();

//   if (day == 0) {
//     // день недели 0 (воскресенье) в европейской нумерации будет 7
//     day = 7;
//   }

//   return day;
// }

// EX 3 Какой день месяца был много дней назад?
// function getDateAgo(date, days) {
//   let dateCopy = new Date(date);

//   dateCopy.setDate(date.getDate() - days);
//   return dateCopy.getDate();
// }

// let date = new Date(2015, 0, 2);

// alert(getDateAgo(date, 1)); // 1, (1 Jan 2015)
// alert(getDateAgo(date, 2)); // 31, (31 Dec 2014)

// EX 4 Последнее число месяца?
// function getLastDayOfMonth(year, month) {
//   let date = new Date(year, month + 1, 0);
//   return date.getDate();
// }

// alert(getLastDayOfMonth(2021, 1)); // 31

// 6.1 Рекурсия и стек

// стек контекстов выполнения, вложенный вызов, контекст, базовый случай и рекурсивный случай

// Рекурсия – это приём программирования, полезный в ситуациях, когда задача может быть естественно разделена
// на несколько аналогичных, но более простых задач.

// В процессе выполнения задачи в теле функции могут быть вызваны другие функции для выполнения подзадач.
// рекурсию используют, когда вычисление функции можно свести к её более простому вызову, а его – к ещё более простому и так далее,
// пока значение не станет очевидно.Частный случай подвызова – когда функция вызывает сама себя. Это как раз и называется рекурсией.

// function pow(x, n) {
//     if (n == 1) {
//       return x;
//     } else {
//       return x * pow(x, n - 1);
//     }
//   }

//   alert( pow(2, 3) ); // 8

// Общее количество вложенных вызовов (включая первый) называют глубиной рекурсии.В нашем случае она будет равна ровно n.
// рекурсивный способ решения даёт более простой код, который легче поддерживать.

// Контекст выполнения, стек

// Информация о процессе выполнения запущенной функции хранится в её контексте выполнения (execution context).
// Контекст выполнения – специальная внутренняя структура данных, которая содержит информацию о вызове функции.
//  Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции,
//  значение this (мы не используем его в данном примере) и прочую служебную информацию.
// Один вызов функции имеет ровно один контекст выполнения, связанный с ним.
// Когда функция производит вложенный вызов, происходит следующее:
// Выполнение текущей функции приостанавливается.
// Контекст выполнения, связанный с ней, запоминается в специальной структуре данных – стеке контекстов выполнения.
// Выполняются вложенные вызовы, для каждого из которых создаётся свой контекст выполнения.
// После их завершения старый контекст достаётся из стека, и выполнение внешней функции возобновляется с того места, где она была остановлена.

// Текущий контекст «запоминается» на вершине стека.
// Создаётся новый контекст для вложенного вызова.
// Когда выполнение вложенного вызова заканчивается – контекст предыдущего вызова восстанавливается,
// и выполнение соответствующей функции продолжается.

// глубина рекурсии равна максимальному числу контекстов, одновременно хранимых в стеке.

// Рекурсивные обходы

// Рекурсивные структуры

// Рекурсивная (рекурсивно определяемая) структура данных – это структура, которая повторяет саму себя в своих частях.

// Отдел компании – это:

// Либо массив людей.
// Либо объект с отделами.

// Элемент связанного списка определяется рекурсивно как объект с:

// value,
// next – свойство, ссылающееся на следующий элемент связанного списка или null, если это последний элемент.
// Пример:

// let list = {
//   value: 1,
//   next: {
//     value: 2,
//     next: {
//       value: 3,
//       next: {
//         value: 4,
//         next: null
//       }
//     }
//   }
// };

// Итого
// Термины:

// Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть использованы для
// элегантного решения определённых задач.

// Когда функция вызывает саму себя, это называется шагом рекурсии. База рекурсии – это такие аргументы функции, которые делают задачу
//  настолько простой, что решение не требует дальнейших вложенных вызовов.

// Рекурсивно определяемая структура данных – это структура данных, которая может быть определена с использованием самой себя.

// Например, связанный список может быть определён как структура данных, состоящая из объекта, содержащего ссылку на список (или null).

// list = { value, next -> list }
// Деревья, такие как дерево HTML-элементов или дерево отделов из этой главы, также являются рекурсивными: они разветвляются, и
// каждая ветвь может содержать другие ветви.

// Как мы видели в примере sumSalary, рекурсивные функции могут быть использованы для прохода по ним.

// Любая рекурсивная функция может быть переписана в итеративную. И это иногда требуется для оптимизации работы. Но для многих
// задач рекурсивное решение достаточно быстрое и простое в написании и поддержке.

// 6.4 Устаревшее ключевое слово "var"

// Итого
// Существует 2 основных отличия var от let/const:

// Переменные var не имеют блочной области видимости, они ограничены, как минимум, телом функции.
// Объявления (инициализация) переменных varпроизводится в начале исполнения функции (или скрипта для глобальных переменных).

// if (true) {
//     var test = true; // используем var вместо let
//   }

//   alert(test); // true, переменная существует вне блока if
//   Так как var игнорирует блоки, мы получили глобальную переменную test.

// 6.5 Глобальный объект

// Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.
//  По умолчанию это те, что встроены в язык или среду исполнения.

//  Итого
// Глобальный объект хранит переменные, которые должны быть доступны в любом месте программы.

// Это включает в себя как встроенные объекты, например, Array, так и характерные для окружения свойства, например, window.innerHeight
// – высота окна браузера.

// Глобальный объект имеет универсальное имя – globalThis.
// …Но чаще на него ссылаются по-старому, используя имя, характерное для данного окружения, такое как window (браузер) и global (Node.js).
// Так как globalThis появился недавно, он не поддерживается в IE и Edge (не-Chromium версия), но можно использовать полифил.
// Следует хранить значения в глобальном объекте, только если они действительно глобальны для нашего проекта. И стараться свести их
// количество к минимуму.
// В браузерах, если только мы не используем модули, глобальные функции и переменные, объявленные с помощью var, становятся свойствами
// глобального объекта.
// Для того, чтобы код был проще и в будущем его легче было поддерживать, следует обращаться к свойствам глобального объекта напрямую,
//  как window.x.
